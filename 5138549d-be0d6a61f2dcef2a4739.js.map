{"version":3,"file":"5138549d-be0d6a61f2dcef2a4739.js","mappings":"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","sources":["webpack://@react-babylonjs/docs/../react-babylonjs/node_modules/@babylonjs/core/Meshes/mesh.js"],"sourcesContent":["import { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @internal\n **/\nexport class _CreationDataStorage {}\n/**\n * @internal\n **/\nclass _InstanceDataStorage {\n  constructor() {\n    this.visibleInstances = {};\n    this.batchCache = new _InstancesBatch();\n    this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n    this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n  }\n}\n/**\n * @internal\n **/\nexport class _InstancesBatch {\n  constructor() {\n    this.mustReturn = false;\n    this.visibleInstances = new Array();\n    this.renderSelf = new Array();\n    this.hardwareInstancedRendering = new Array();\n  }\n}\n/**\n * @internal\n **/\nclass _ThinInstanceDataStorage {\n  constructor() {\n    this.instancesCount = 0;\n    this.matrixBuffer = null;\n    this.previousMatrixBuffer = null;\n    this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n    this.matrixData = null;\n    this.boundingVectors = [];\n    this.worldMatrices = null;\n  }\n}\n/**\n * @internal\n **/\nclass _InternalMeshDataInfo {\n  constructor() {\n    this._areNormalsFrozen = false; // Will be used by ribbons mainly\n    // Will be used to save a source mesh reference, If any\n    this._source = null;\n    // Will be used to for fast cloned mesh lookup\n    this.meshMap = null;\n    this._preActivateId = -1;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._LODLevels = new Array();\n    /** Alternative definition of LOD level, using screen coverage instead of distance */\n    this._useLODScreenCoverage = false;\n    this._effectiveMaterial = null;\n    this._forcedInstanceCount = 0;\n    this._overrideRenderingFillMode = null;\n  }\n}\n/**\n * Class used to represent renderable models\n */\nexport class Mesh extends AbstractMesh {\n  /**\n   * Gets the default side orientation.\n   * @param orientation the orientation to value to attempt to get\n   * @returns the default orientation\n   * @internal\n   */\n  static _GetDefaultSideOrientation(orientation) {\n    return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n  }\n  /**\n   * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance.\n   */\n  get useLODScreenCoverage() {\n    return this._internalMeshDataInfo._useLODScreenCoverage;\n  }\n  set useLODScreenCoverage(value) {\n    this._internalMeshDataInfo._useLODScreenCoverage = value;\n    this._sortLODLevels();\n  }\n  get computeBonesUsingShaders() {\n    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n  }\n  set computeBonesUsingShaders(value) {\n    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n      return;\n    }\n    if (value && this._internalMeshDataInfo._sourcePositions) {\n      // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n      this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n      if (this._internalMeshDataInfo._sourceNormals) {\n        this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n      }\n      this._internalMeshDataInfo._sourcePositions = null;\n      this._internalMeshDataInfo._sourceNormals = null;\n    }\n    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n    this._markSubMeshesAsAttributesDirty();\n  }\n  /**\n   * An event triggered before rendering the mesh\n   */\n  get onBeforeRenderObservable() {\n    if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n      this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeRenderObservable;\n  }\n  /**\n   * An event triggered before binding the mesh\n   */\n  get onBeforeBindObservable() {\n    if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n      this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeBindObservable;\n  }\n  /**\n   * An event triggered after rendering the mesh\n   */\n  get onAfterRenderObservable() {\n    if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n      this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onAfterRenderObservable;\n  }\n  /**\n   * An event triggeredbetween rendering pass when using separateCullingPass = true\n   */\n  get onBetweenPassObservable() {\n    if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n      this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBetweenPassObservable;\n  }\n  /**\n   * An event triggered before drawing the mesh\n   */\n  get onBeforeDrawObservable() {\n    if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n      this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeDrawObservable;\n  }\n  /**\n   * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n   */\n  set onBeforeDraw(callback) {\n    if (this._onBeforeDrawObserver) {\n      this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n    }\n    this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n  }\n  get hasInstances() {\n    return this.instances.length > 0;\n  }\n  get hasThinInstances() {\n    var _a;\n    return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\n  }\n  /**\n   * Gets or sets the forced number of instances to display.\n   * If 0 (default value), the number of instances is not forced and depends on the draw type\n   * (regular / instance / thin instances mesh)\n   */\n  get forcedInstanceCount() {\n    return this._internalMeshDataInfo._forcedInstanceCount;\n  }\n  set forcedInstanceCount(count) {\n    this._internalMeshDataInfo._forcedInstanceCount = count;\n  }\n  /**\n   * Use this property to override the Material's fillMode value\n   */\n  get overrideRenderingFillMode() {\n    return this._internalMeshDataInfo._overrideRenderingFillMode;\n  }\n  set overrideRenderingFillMode(fillMode) {\n    this._internalMeshDataInfo._overrideRenderingFillMode = fillMode;\n  }\n  /**\n   * Gets the source mesh (the one used to clone this one from)\n   */\n  get source() {\n    return this._internalMeshDataInfo._source;\n  }\n  /**\n   * Gets the list of clones of this mesh\n   * The scene must have been constructed with useClonedMeshMap=true for this to work!\n   * Note that useClonedMeshMap=true is the default setting\n   */\n  get cloneMeshMap() {\n    return this._internalMeshDataInfo.meshMap;\n  }\n  /**\n   * Gets or sets a boolean indicating that this mesh does not use index buffer\n   */\n  get isUnIndexed() {\n    return this._unIndexed;\n  }\n  set isUnIndexed(value) {\n    if (this._unIndexed !== value) {\n      this._unIndexed = value;\n      this._markSubMeshesAsAttributesDirty();\n    }\n  }\n  /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n  get worldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.instancesData;\n  }\n  /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n  get previousWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.instancesPreviousData;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  get manualUpdateOfWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.manualUpdate;\n  }\n  set manualUpdateOfWorldMatrixInstancedBuffer(value) {\n    this._instanceDataStorage.manualUpdate = value;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.previousManualUpdate;\n  }\n  set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {\n    this._instanceDataStorage.previousManualUpdate = value;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices must be performed in all cases (and notably even in frozen mode) */\n  get forceWorldMatrixInstancedBufferUpdate() {\n    return this._instanceDataStorage.forceMatrixUpdates;\n  }\n  set forceWorldMatrixInstancedBufferUpdate(value) {\n    this._instanceDataStorage.forceMatrixUpdates = value;\n  }\n  /**\n   * @constructor\n   * @param name The value used by scene.getMeshByName() to do a lookup.\n   * @param scene The scene to add this mesh to.\n   * @param parent The parent of this mesh, if it has one\n   * @param source An optional Mesh from which geometry is shared, cloned.\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   *                  When false, achieved by calling a clone(), also passing False.\n   *                  This will make creation of children, recursive.\n   * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n   */\n  constructor(name) {\n    let scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let doNotCloneChildren = arguments.length > 4 ? arguments[4] : undefined;\n    let clonePhysicsImpostor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    super(name, scene);\n    // Internal data\n    this._internalMeshDataInfo = new _InternalMeshDataInfo();\n    // Members\n    /**\n     * Gets the delay loading state of the mesh (when delay loading is turned on)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/incrementalLoading\n     */\n    this.delayLoadState = 0;\n    /**\n     * Gets the list of instances created from this mesh\n     * it is not supposed to be modified manually.\n     * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n     */\n    this.instances = new Array();\n    // Private\n    /** @internal */\n    this._creationDataStorage = null;\n    /** @internal */\n    this._geometry = null;\n    /** @internal */\n    this._instanceDataStorage = new _InstanceDataStorage();\n    /** @internal */\n    this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n    /** @internal */\n    this._shouldGenerateFlatShading = false;\n    // Use by builder only to know what orientation were the mesh build in.\n    /** @internal */\n    this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n    /**\n     * Use this property to change the original side orientation defined at construction time\n     */\n    this.overrideMaterialSideOrientation = null;\n    /**\n     * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n     * Note this will reduce performance when set to true.\n     */\n    this.ignoreCameraMaxZ = false;\n    scene = this.getScene();\n    this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {\n      if (isInstance && effectiveMaterial) {\n        if (this._uniformBuffer) {\n          this.transferToEffect(world);\n        } else {\n          effectiveMaterial.bindOnlyWorldMatrix(world);\n        }\n      }\n    };\n    if (source) {\n      // Geometry\n      if (source._geometry) {\n        source._geometry.applyToMesh(this);\n      }\n      // Deep copy\n      DeepCopier.DeepCopy(source, this, [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"morphTargetManager\", \"hasInstances\", \"worldMatrixInstancedBuffer\", \"previousWorldMatrixInstancedBuffer\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\", \"facetNb\", \"isFacetDataEnabled\", \"lightSources\", \"useBones\", \"isAnInstance\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"cloneMeshMap\", \"hasBoundingInfo\"], [\"_poseMatrix\"]);\n      // Source mesh\n      this._internalMeshDataInfo._source = source;\n      if (scene.useClonedMeshMap) {\n        if (!source._internalMeshDataInfo.meshMap) {\n          source._internalMeshDataInfo.meshMap = {};\n        }\n        source._internalMeshDataInfo.meshMap[this.uniqueId] = this;\n      }\n      // Construction Params\n      // Clone parameters allowing mesh to be updated in case of parametric shapes.\n      this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n      this._creationDataStorage = source._creationDataStorage;\n      // Animation ranges\n      if (source._ranges) {\n        const ranges = source._ranges;\n        for (const name in ranges) {\n          if (!Object.prototype.hasOwnProperty.call(ranges, name)) {\n            continue;\n          }\n          if (!ranges[name]) {\n            continue;\n          }\n          this.createAnimationRange(name, ranges[name].from, ranges[name].to);\n        }\n      }\n      // Metadata\n      if (source.metadata && source.metadata.clone) {\n        this.metadata = source.metadata.clone();\n      } else {\n        this.metadata = source.metadata;\n      }\n      this._internalMetadata = source._internalMetadata;\n      // Tags\n      if (Tags && Tags.HasTags(source)) {\n        Tags.AddTagsTo(this, Tags.GetTags(source, true));\n      }\n      // Enabled. We shouldn't need to check the source's ancestors, as this mesh\n      // will have the same ones.\n      this.setEnabled(source.isEnabled(false));\n      // Parent\n      this.parent = source.parent;\n      // Pivot\n      this.setPivotMatrix(source.getPivotMatrix());\n      this.id = name + \".\" + source.id;\n      // Material\n      this.material = source.material;\n      if (!doNotCloneChildren) {\n        // Children\n        const directDescendants = source.getDescendants(true);\n        for (let index = 0; index < directDescendants.length; index++) {\n          const child = directDescendants[index];\n          if (child.clone) {\n            child.clone(name + \".\" + child.name, this);\n          }\n        }\n      }\n      // Morphs\n      if (source.morphTargetManager) {\n        this.morphTargetManager = source.morphTargetManager;\n      }\n      // Physics clone\n      if (scene.getPhysicsEngine) {\n        const physicsEngine = scene.getPhysicsEngine();\n        if (clonePhysicsImpostor && physicsEngine) {\n          if (physicsEngine.getPluginVersion() === 1) {\n            const impostor = physicsEngine.getImpostorForPhysicsObject(source);\n            if (impostor) {\n              this.physicsImpostor = impostor.clone(this);\n            }\n          } else if (physicsEngine.getPluginVersion() === 2) {\n            if (source.physicsBody) {\n              source.physicsBody.clone(this);\n            }\n          }\n        }\n      }\n      // Particles\n      for (let index = 0; index < scene.particleSystems.length; index++) {\n        const system = scene.particleSystems[index];\n        if (system.emitter === source) {\n          system.clone(system.name, this);\n        }\n      }\n      // Skeleton\n      this.skeleton = source.skeleton;\n      this.refreshBoundingInfo(true, true);\n      this.computeWorldMatrix(true);\n    }\n    // Parent\n    if (parent !== null) {\n      this.parent = parent;\n    }\n    this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;\n    this._internalMeshDataInfo._onMeshReadyObserverAdded = observer => {\n      // only notify once! then unregister the observer\n      observer.unregisterOnNextCall = true;\n      if (this.isReady(true)) {\n        this.onMeshReadyObservable.notifyObservers(this);\n      } else {\n        if (!this._internalMeshDataInfo._checkReadinessObserver) {\n          this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {\n            // check for complete readiness\n            if (this.isReady(true)) {\n              this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n              this._internalMeshDataInfo._checkReadinessObserver = null;\n              this.onMeshReadyObservable.notifyObservers(this);\n            }\n          });\n        }\n      }\n    };\n    this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);\n    if (source) {\n      source.onClonedObservable.notifyObservers(this);\n    }\n  }\n  instantiateHierarchy() {\n    let newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    let onNewNodeCreated = arguments.length > 2 ? arguments[2] : undefined;\n    const instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true) : this.createInstance(\"instance of \" + (this.name || this.id));\n    instance.parent = newParent || this.parent;\n    instance.position = this.position.clone();\n    instance.scaling = this.scaling.clone();\n    if (this.rotationQuaternion) {\n      instance.rotationQuaternion = this.rotationQuaternion.clone();\n    } else {\n      instance.rotation = this.rotation.clone();\n    }\n    if (onNewNodeCreated) {\n      onNewNodeCreated(this, instance);\n    }\n    for (const child of this.getChildTransformNodes(true)) {\n      // instancedMesh should have a different sourced mesh\n      if (child.getClassName() === \"InstancedMesh\" && instance.getClassName() === \"Mesh\" && child.sourceMesh === this) {\n        child.instantiateHierarchy(instance, {\n          doNotInstantiate: options && options.doNotInstantiate || false,\n          newSourcedMesh: instance\n        }, onNewNodeCreated);\n      } else {\n        child.instantiateHierarchy(instance, options, onNewNodeCreated);\n      }\n    }\n    return instance;\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"Mesh\".\n   */\n  getClassName() {\n    return \"Mesh\";\n  }\n  /** @internal */\n  get _isMesh() {\n    return true;\n  }\n  /**\n   * Returns a description of this mesh\n   * @param fullDetails define if full details about this mesh must be used\n   * @returns a descriptive string representing this mesh\n   */\n  toString(fullDetails) {\n    let ret = super.toString(fullDetails);\n    ret += \", n vertices: \" + this.getTotalVertices();\n    ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    if (fullDetails) {\n      if (this._geometry) {\n        const ib = this.getIndices();\n        const vb = this.getVerticesData(VertexBuffer.PositionKind);\n        if (vb && ib) {\n          ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n        }\n      } else {\n        ret += \", flat shading: UNKNOWN\";\n      }\n    }\n    return ret;\n  }\n  /** @internal */\n  _unBindEffect() {\n    super._unBindEffect();\n    for (const instance of this.instances) {\n      instance._unBindEffect();\n    }\n  }\n  /**\n   * Gets a boolean indicating if this mesh has LOD\n   */\n  get hasLODLevels() {\n    return this._internalMeshDataInfo._LODLevels.length > 0;\n  }\n  /**\n   * Gets the list of MeshLODLevel associated with the current mesh\n   * @returns an array of MeshLODLevel\n   */\n  getLODLevels() {\n    return this._internalMeshDataInfo._LODLevels;\n  }\n  _sortLODLevels() {\n    const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n    this._internalMeshDataInfo._LODLevels.sort((a, b) => {\n      if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n        return sortingOrderFactor;\n      }\n      if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n        return -sortingOrderFactor;\n      }\n      return 0;\n    });\n  }\n  /**\n   * Add a mesh as LOD level triggered at the given distance.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n   * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n   * Example Playground for distance https://playground.babylonjs.com/#QE7KM#197\n   * Example Playground for screen coverage https://playground.babylonjs.com/#QE7KM#196\n   * @param mesh The mesh to be added as LOD level (can be null)\n   * @returns This mesh (for chaining)\n   */\n  addLODLevel(distanceOrScreenCoverage, mesh) {\n    if (mesh && mesh._masterMesh) {\n      Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n      return this;\n    }\n    const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n    this._internalMeshDataInfo._LODLevels.push(level);\n    if (mesh) {\n      mesh._masterMesh = this;\n    }\n    this._sortLODLevels();\n    return this;\n  }\n  /**\n   * Returns the LOD level mesh at the passed distance or null if not found.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param distance The distance from the center of the object to show this level\n   * @returns a Mesh or `null`\n   */\n  getLODLevelAtDistance(distance) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      const level = internalDataInfo._LODLevels[index];\n      if (level.distanceOrScreenCoverage === distance) {\n        return level.mesh;\n      }\n    }\n    return null;\n  }\n  /**\n   * Remove a mesh from the LOD array\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param mesh defines the mesh to be removed\n   * @returns This mesh (for chaining)\n   */\n  removeLODLevel(mesh) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      if (internalDataInfo._LODLevels[index].mesh === mesh) {\n        internalDataInfo._LODLevels.splice(index, 1);\n        if (mesh) {\n          mesh._masterMesh = null;\n        }\n      }\n    }\n    this._sortLODLevels();\n    return this;\n  }\n  /**\n   * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param camera defines the camera to use to compute distance\n   * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n   * @returns This mesh (for chaining)\n   */\n  getLOD(camera, boundingSphere) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n      return this;\n    }\n    const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;\n    const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();\n    let compareValue = distanceToCamera;\n    let compareSign = 1;\n    if (internalDataInfo._useLODScreenCoverage) {\n      const screenArea = camera.screenArea;\n      let meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;\n      meshArea = meshArea * meshArea * Math.PI;\n      compareValue = meshArea / screenArea;\n      compareSign = -1;\n    }\n    if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n      if (this.onLODLevelSelection) {\n        this.onLODLevelSelection(compareValue, this, this);\n      }\n      return this;\n    }\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      const level = internalDataInfo._LODLevels[index];\n      if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n        if (level.mesh) {\n          if (level.mesh.delayLoadState === 4) {\n            level.mesh._checkDelayState();\n            return this;\n          }\n          if (level.mesh.delayLoadState === 2) {\n            return this;\n          }\n          level.mesh._preActivate();\n          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n        }\n        if (this.onLODLevelSelection) {\n          this.onLODLevelSelection(compareValue, this, level.mesh);\n        }\n        return level.mesh;\n      }\n    }\n    if (this.onLODLevelSelection) {\n      this.onLODLevelSelection(compareValue, this, this);\n    }\n    return this;\n  }\n  /**\n   * Gets the mesh internal Geometry object\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  /**\n   * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    if (this._geometry === null || this._geometry === undefined) {\n      return 0;\n    }\n    return this._geometry.getTotalVertices();\n  }\n  /**\n   * Returns the content of an associated vertex buffer\n   * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {\n    var _a, _b;\n    if (!this._geometry) {\n      return null;\n    }\n    let data = bypassInstanceData ? undefined : (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this.instances.length + 1,\n    // +1 because the master mesh is not included in the instances array\n    forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);\n    if (!data) {\n      data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n    }\n    return data;\n  }\n  /**\n   * Returns the mesh VertexBuffer object from the requested `kind`\n   * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.NormalKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n   */\n  getVertexBuffer(kind, bypassInstanceData) {\n    var _a, _b;\n    if (!this._geometry) {\n      return null;\n    }\n    return (_b = bypassInstanceData ? undefined : (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);\n  }\n  /**\n   * Tests if a specific vertex buffer is associated with this mesh\n   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.NormalKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a boolean\n   */\n  isVerticesDataPresent(kind, bypassInstanceData) {\n    var _a;\n    if (!this._geometry) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    return !bypassInstanceData && ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== undefined || this._geometry.isVerticesDataPresent(kind);\n  }\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a boolean\n   */\n  isVertexBufferUpdatable(kind, bypassInstanceData) {\n    var _a;\n    if (!this._geometry) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    if (!bypassInstanceData) {\n      const buffer = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind];\n      if (buffer) {\n        return buffer.isUpdatable();\n      }\n    }\n    return this._geometry.isVertexBufferUpdatable(kind);\n  }\n  /**\n   * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns an array of strings\n   */\n  getVerticesDataKinds(bypassInstanceData) {\n    if (!this._geometry) {\n      const result = new Array();\n      if (this._delayInfo) {\n        this._delayInfo.forEach(function (kind) {\n          result.push(kind);\n        });\n      }\n      return result;\n    }\n    const kinds = this._geometry.getVerticesDataKinds();\n    if (!bypassInstanceData && this._userInstancedBuffersStorage) {\n      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n        if (kinds.indexOf(kind) === -1) {\n          kinds.push(kind);\n        }\n      }\n    }\n    return kinds;\n  }\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the numner of indices or zero if the mesh has no geometry.\n   */\n  getTotalIndices() {\n    if (!this._geometry) {\n      return 0;\n    }\n    return this._geometry.getTotalIndices();\n  }\n  /**\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the indices array or an empty array if the mesh has no geometry\n   */\n  getIndices(copyWhenShared, forceCopy) {\n    if (!this._geometry) {\n      return [];\n    }\n    return this._geometry.getIndices(copyWhenShared, forceCopy);\n  }\n  get isBlocked() {\n    return this._masterMesh !== null && this._masterMesh !== undefined;\n  }\n  /**\n   * Determine if the current mesh is ready to be rendered\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n   * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n   * @returns true if all associated assets are ready (material, textures, shaders)\n   */\n  isReady() {\n    let completeCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let forceInstanceSupport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _a, _b, _c, _d, _e, _f;\n    if (this.delayLoadState === 2) {\n      return false;\n    }\n    if (!super.isReady(completeCheck)) {\n      return false;\n    }\n    if (!this.subMeshes || this.subMeshes.length === 0) {\n      return true;\n    }\n    if (!completeCheck) {\n      return true;\n    }\n    const engine = this.getEngine();\n    const scene = this.getScene();\n    const hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);\n    this.computeWorldMatrix();\n    const mat = this.material || scene.defaultMaterial;\n    if (mat) {\n      if (mat._storeEffectOnSubMeshes) {\n        for (const subMesh of this.subMeshes) {\n          const effectiveMaterial = subMesh.getMaterial();\n          if (effectiveMaterial) {\n            if (effectiveMaterial._storeEffectOnSubMeshes) {\n              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                return false;\n              }\n            } else {\n              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                return false;\n              }\n            }\n          }\n        }\n      } else {\n        if (!mat.isReady(this, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    }\n    // Shadows\n    const currentRenderPassId = engine.currentRenderPassId;\n    for (const light of this.lightSources) {\n      const generators = light.getShadowGenerators();\n      if (!generators) {\n        continue;\n      }\n      const iterator = generators.values();\n      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n        const generator = key.value;\n        if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {\n          if (generator.getShadowMap()) {\n            engine.currentRenderPassId = generator.getShadowMap().renderPassId;\n          }\n          for (const subMesh of this.subMeshes) {\n            if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {\n              engine.currentRenderPassId = currentRenderPassId;\n              return false;\n            }\n          }\n          engine.currentRenderPassId = currentRenderPassId;\n        }\n      }\n    }\n    // LOD\n    for (const lod of this._internalMeshDataInfo._LODLevels) {\n      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n   */\n  get areNormalsFrozen() {\n    return this._internalMeshDataInfo._areNormalsFrozen;\n  }\n  /**\n   * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n   * @returns the current mesh\n   */\n  freezeNormals() {\n    this._internalMeshDataInfo._areNormalsFrozen = true;\n    return this;\n  }\n  /**\n   * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n   * @returns the current mesh\n   */\n  unfreezeNormals() {\n    this._internalMeshDataInfo._areNormalsFrozen = false;\n    return this;\n  }\n  /**\n   * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n   */\n  set overridenInstanceCount(count) {\n    this._instanceDataStorage.overridenInstanceCount = count;\n  }\n  // Methods\n  /** @internal */\n  _preActivate() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    const sceneRenderId = this.getScene().getRenderId();\n    if (internalDataInfo._preActivateId === sceneRenderId) {\n      return this;\n    }\n    internalDataInfo._preActivateId = sceneRenderId;\n    this._instanceDataStorage.visibleInstances = null;\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _preActivateForIntermediateRendering(renderId) {\n    if (this._instanceDataStorage.visibleInstances) {\n      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _registerInstanceForRenderId(instance, renderId) {\n    if (!this._instanceDataStorage.visibleInstances) {\n      this._instanceDataStorage.visibleInstances = {\n        defaultRenderId: renderId,\n        selfDefaultRenderId: this._renderId\n      };\n    }\n    if (!this._instanceDataStorage.visibleInstances[renderId]) {\n      if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n      }\n      this._instanceDataStorage.previousRenderId = renderId;\n      this._instanceDataStorage.visibleInstances[renderId] = new Array();\n    }\n    this._instanceDataStorage.visibleInstances[renderId].push(instance);\n    return this;\n  }\n  _afterComputeWorldMatrix() {\n    super._afterComputeWorldMatrix();\n    if (!this.hasThinInstances) {\n      return;\n    }\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n  /** @internal */\n  _postActivate() {\n    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n      this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n    }\n  }\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n  refreshBoundingInfo() {\n    let applySkeleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let applyMorph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n      return this;\n    }\n    const bias = this.geometry ? this.geometry.boundingBias : null;\n    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _createGlobalSubMesh(force) {\n    const totalVertices = this.getTotalVertices();\n    if (!totalVertices || !this.getIndices()) {\n      return null;\n    }\n    // Check if we need to recreate the submeshes\n    if (this.subMeshes && this.subMeshes.length > 0) {\n      const ib = this.getIndices();\n      if (!ib) {\n        return null;\n      }\n      const totalIndices = ib.length;\n      let needToRecreate = false;\n      if (force) {\n        needToRecreate = true;\n      } else {\n        for (const submesh of this.subMeshes) {\n          if (submesh.indexStart + submesh.indexCount > totalIndices) {\n            needToRecreate = true;\n            break;\n          }\n          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n            needToRecreate = true;\n            break;\n          }\n        }\n      }\n      if (!needToRecreate) {\n        return this.subMeshes[0];\n      }\n    }\n    this.releaseSubMeshes();\n    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n  }\n  /**\n   * This function will subdivide the mesh into multiple submeshes\n   * @param count defines the expected number of submeshes\n   */\n  subdivide(count) {\n    if (count < 1) {\n      return;\n    }\n    const totalIndices = this.getTotalIndices();\n    let subdivisionSize = totalIndices / count | 0;\n    let offset = 0;\n    // Ensure that subdivisionSize is a multiple of 3\n    while (subdivisionSize % 3 !== 0) {\n      subdivisionSize++;\n    }\n    this.releaseSubMeshes();\n    for (let index = 0; index < count; index++) {\n      if (offset >= totalIndices) {\n        break;\n      }\n      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n      offset += subdivisionSize;\n    }\n    this.synchronizeInstances();\n  }\n  /**\n   * Copy a FloatArray into a specific associated vertex buffer\n   * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updatable defines if the updated vertex buffer must be flagged as updatable\n   * @param stride defines the data stride size (can be null)\n   * @returns the current mesh\n   */\n  setVerticesData(kind, data) {\n    let updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let stride = arguments.length > 3 ? arguments[3] : undefined;\n    if (!this._geometry) {\n      const vertexData = new VertexData();\n      vertexData.set(data, kind);\n      const scene = this.getScene();\n      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n    } else {\n      this._geometry.setVerticesData(kind, data, updatable, stride);\n    }\n    return this;\n  }\n  /**\n   * Delete a vertex buffer associated with this mesh\n   * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   */\n  removeVerticesData(kind) {\n    if (!this._geometry) {\n      return;\n    }\n    this._geometry.removeVerticesData(kind);\n  }\n  /**\n   * Flags an associated vertex buffer as updatable\n   * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param updatable defines if the updated vertex buffer must be flagged as updatable\n   */\n  markVerticesDataAsUpdatable(kind) {\n    let updatable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const vb = this.getVertexBuffer(kind);\n    if (!vb || vb.isUpdatable() === updatable) {\n      return;\n    }\n    this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n  }\n  /**\n   * Sets the mesh global Vertex Buffer\n   * @param buffer defines the buffer to use\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   * @returns the current mesh\n   */\n  setVerticesBuffer(buffer) {\n    let disposeExistingBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!this._geometry) {\n      this._geometry = Geometry.CreateGeometryForMesh(this);\n    }\n    this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n    return this;\n  }\n  /**\n   * Update a specific associated vertex buffer\n   * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n   * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n   * @returns the current mesh\n   */\n  updateVerticesData(kind, data, updateExtends, makeItUnique) {\n    if (!this._geometry) {\n      return this;\n    }\n    if (!makeItUnique) {\n      this._geometry.updateVerticesData(kind, data, updateExtends);\n    } else {\n      this.makeGeometryUnique();\n      this.updateVerticesData(kind, data, updateExtends, false);\n    }\n    return this;\n  }\n  /**\n   * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#other-shapes-updatemeshpositions\n   * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n   * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n   * @returns the current mesh\n   */\n  updateMeshPositions(positionFunction) {\n    let computeNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions) {\n      return this;\n    }\n    positionFunction(positions);\n    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n    if (computeNormals) {\n      const indices = this.getIndices();\n      const normals = this.getVerticesData(VertexBuffer.NormalKind);\n      if (!normals) {\n        return this;\n      }\n      VertexData.ComputeNormals(positions, indices, normals);\n      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n    }\n    return this;\n  }\n  /**\n   * Creates a un-shared specific occurence of the geometry for the mesh.\n   * @returns the current mesh\n   */\n  makeGeometryUnique() {\n    if (!this._geometry) {\n      return this;\n    }\n    if (this._geometry.meshes.length === 1) {\n      return this;\n    }\n    const oldGeometry = this._geometry;\n    const geometry = this._geometry.copy(Geometry.RandomId());\n    oldGeometry.releaseForMesh(this, true);\n    geometry.applyToMesh(this);\n    return this;\n  }\n  /**\n   * Set the index buffer of this mesh\n   * @param indices defines the source data\n   * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n   * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n   * @returns the current mesh\n   */\n  setIndices(indices) {\n    let totalVertices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this._geometry) {\n      const vertexData = new VertexData();\n      vertexData.indices = indices;\n      const scene = this.getScene();\n      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n    } else {\n      this._geometry.setIndices(indices, totalVertices, updatable);\n    }\n    return this;\n  }\n  /**\n   * Update the current index buffer\n   * @param indices defines the source data\n   * @param offset defines the offset in the index buffer where to store the new data (can be null)\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   * @returns the current mesh\n   */\n  updateIndices(indices, offset) {\n    let gpuMemoryOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this._geometry) {\n      return this;\n    }\n    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n    return this;\n  }\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   * @returns the current mesh\n   */\n  toLeftHanded() {\n    if (!this._geometry) {\n      return this;\n    }\n    this._geometry.toLeftHanded();\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _bind(subMesh, effect, fillMode) {\n    let allowInstancedRendering = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!this._geometry) {\n      return this;\n    }\n    const engine = this.getScene().getEngine();\n    // Morph targets\n    if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n      this.morphTargetManager._bind(effect);\n    }\n    // Wireframe\n    let indexToBind;\n    if (this._unIndexed) {\n      indexToBind = null;\n    } else {\n      switch (this._getRenderingFillMode(fillMode)) {\n        case Material.PointFillMode:\n          indexToBind = null;\n          break;\n        case Material.WireFrameFillMode:\n          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n          break;\n        default:\n        case Material.TriangleFillMode:\n          indexToBind = this._geometry.getIndexBuffer();\n          break;\n      }\n    }\n    // VBOs\n    if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {\n      this._geometry._bind(effect, indexToBind);\n    } else {\n      this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _draw(subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n    if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n    }\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    if (this._unIndexed || fillMode == Material.PointFillMode) {\n      // or triangles as points\n      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n    } else if (fillMode == Material.WireFrameFillMode) {\n      // Triangles as wireframe\n      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n    } else {\n      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n    }\n    return this;\n  }\n  /**\n   * Registers for this mesh a javascript function called just before the rendering process\n   * @param func defines the function to call before rendering this mesh\n   * @returns the current mesh\n   */\n  registerBeforeRender(func) {\n    this.onBeforeRenderObservable.add(func);\n    return this;\n  }\n  /**\n   * Disposes a previously registered javascript function called before the rendering\n   * @param func defines the function to remove\n   * @returns the current mesh\n   */\n  unregisterBeforeRender(func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n    return this;\n  }\n  /**\n   * Registers for this mesh a javascript function called just after the rendering is complete\n   * @param func defines the function to call after rendering this mesh\n   * @returns the current mesh\n   */\n  registerAfterRender(func) {\n    this.onAfterRenderObservable.add(func);\n    return this;\n  }\n  /**\n   * Disposes a previously registered javascript function called after the rendering.\n   * @param func defines the function to remove\n   * @returns the current mesh\n   */\n  unregisterAfterRender(func) {\n    this.onAfterRenderObservable.removeCallback(func);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _getInstancesRenderList(subMeshId) {\n    let isReplacementMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this._instanceDataStorage.isFrozen) {\n      if (isReplacementMode) {\n        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n      }\n      if (this._instanceDataStorage.previousBatch) {\n        return this._instanceDataStorage.previousBatch;\n      }\n    }\n    const scene = this.getScene();\n    const isInIntermediateRendering = scene._isInIntermediateRendering();\n    const onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;\n    const batchCache = this._instanceDataStorage.batchCache;\n    batchCache.mustReturn = false;\n    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;\n    batchCache.visibleInstances[subMeshId] = null;\n    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n      const visibleInstances = this._instanceDataStorage.visibleInstances;\n      const currentRenderId = scene.getRenderId();\n      const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n      }\n    }\n    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== undefined;\n    this._instanceDataStorage.previousBatch = batchCache;\n    return batchCache;\n  }\n  /**\n   * @internal\n   */\n  _renderWithInstances(subMesh, fillMode, batch, effect, engine) {\n    var _a;\n    const visibleInstances = batch.visibleInstances[subMesh._id];\n    const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;\n    const instanceStorage = this._instanceDataStorage;\n    const currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n    let instancesBuffer = instanceStorage.instancesBuffer;\n    let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n    const matricesCount = visibleInstanceCount + 1;\n    const bufferSize = matricesCount * 16 * 4;\n    while (instanceStorage.instancesBufferSize < bufferSize) {\n      instanceStorage.instancesBufferSize *= 2;\n    }\n    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n    }\n    if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n      instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n    }\n    let offset = 0;\n    let instancesCount = 0;\n    const renderSelf = batch.renderSelf[subMesh._id];\n    const needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;\n    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n      const world = this.getWorldMatrix();\n      if (renderSelf) {\n        if (this._scene.needsPreviousWorldMatrices) {\n          if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n            instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n          } else {\n            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n          }\n        }\n        world.copyToArray(instanceStorage.instancesData, offset);\n        offset += 16;\n        instancesCount++;\n      }\n      if (visibleInstances) {\n        if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {\n          const cameraPosition = this._scene.activeCamera.globalPosition;\n          for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n            const instanceMesh = visibleInstances[instanceIndex];\n            instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n          }\n          visibleInstances.sort((m1, m2) => {\n            return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n          });\n        }\n        for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n          const instance = visibleInstances[instanceIndex];\n          const matrix = instance.getWorldMatrix();\n          matrix.copyToArray(instanceStorage.instancesData, offset);\n          if (this._scene.needsPreviousWorldMatrices) {\n            if (!instance._previousWorldMatrix) {\n              instance._previousWorldMatrix = matrix.clone();\n              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            } else {\n              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              instance._previousWorldMatrix.copyFrom(matrix);\n            }\n          }\n          offset += 16;\n          instancesCount++;\n        }\n      }\n    } else {\n      instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;\n    }\n    if (needUpdateBuffer) {\n      if (instancesBuffer) {\n        instancesBuffer.dispose();\n      }\n      if (instancesPreviousBuffer) {\n        instancesPreviousBuffer.dispose();\n      }\n      instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n      instanceStorage.instancesBuffer = instancesBuffer;\n      if (!this._userInstancedBuffersStorage) {\n        this._userInstancedBuffersStorage = {\n          data: {},\n          vertexBuffers: {},\n          strides: {},\n          sizes: {},\n          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n        };\n      }\n      this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n      if (this._scene.needsPreviousWorldMatrices) {\n        instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n        instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n      }\n      this._invalidateInstanceVertexArrayObject();\n    } else {\n      if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {\n        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n        if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n        }\n      }\n    }\n    this._processInstancedBuffers(visibleInstances, renderSelf);\n    // Stats\n    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n    // Draw\n    if (engine._currentDrawContext) {\n      engine._currentDrawContext.useInstancing = true;\n    }\n    this._bind(subMesh, effect, fillMode);\n    this._draw(subMesh, fillMode, instancesCount);\n    // Write current matrices as previous matrices in case of manual update\n    // Default behaviour when previous matrices are not specified explicitly\n    // Will break if instances number/order changes\n    if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {\n      instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n    }\n    engine.unbindInstanceAttributes();\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _renderWithThinInstances(subMesh, fillMode, effect, engine) {\n    var _a, _b;\n    // Stats\n    const instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\n    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n    // Draw\n    if (engine._currentDrawContext) {\n      engine._currentDrawContext.useInstancing = true;\n    }\n    this._bind(subMesh, effect, fillMode);\n    this._draw(subMesh, fillMode, instancesCount);\n    // Write current matrices as previous matrices\n    // Default behaviour when previous matrices are not specified explicitly\n    // Will break if instances number/order changes\n    if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n      if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n      } else {\n        this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n      }\n    }\n    engine.unbindInstanceAttributes();\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _processInstancedBuffers(visibleInstances, renderSelf) {\n    // Do nothing\n  }\n  /**\n   * @internal\n   */\n  _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    fillMode = this._getRenderingFillMode(fillMode);\n    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n      this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n      return this;\n    }\n    if (hardwareInstancedRendering) {\n      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n    } else {\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = false;\n      }\n      let instanceCount = 0;\n      if (batch.renderSelf[subMesh._id]) {\n        // Draw\n        if (onBeforeDraw) {\n          onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n        }\n        instanceCount++;\n        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n      }\n      const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n      if (visibleInstancesForSubMesh) {\n        const visibleInstanceCount = visibleInstancesForSubMesh.length;\n        instanceCount += visibleInstanceCount;\n        // Stats\n        for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n          const instance = visibleInstancesForSubMesh[instanceIndex];\n          // World\n          const world = instance.getWorldMatrix();\n          if (onBeforeDraw) {\n            onBeforeDraw(true, world, effectiveMaterial);\n          }\n          // Draw\n          this._draw(subMesh, fillMode);\n        }\n      }\n      // Stats\n      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _rebuild() {\n    let dispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this._instanceDataStorage.instancesBuffer) {\n      // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n      if (dispose) {\n        this._instanceDataStorage.instancesBuffer.dispose();\n      }\n      this._instanceDataStorage.instancesBuffer = null;\n    }\n    if (this._userInstancedBuffersStorage) {\n      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n        const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n        if (buffer) {\n          // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n          if (dispose) {\n            buffer.dispose();\n          }\n          this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n        }\n      }\n      if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n        this._userInstancedBuffersStorage.vertexArrayObjects = {};\n      }\n    }\n    this._internalMeshDataInfo._effectiveMaterial = null;\n    super._rebuild(dispose);\n  }\n  /** @internal */\n  _freeze() {\n    if (!this.subMeshes) {\n      return;\n    }\n    // Prepare batches\n    for (let index = 0; index < this.subMeshes.length; index++) {\n      this._getInstancesRenderList(index);\n    }\n    this._internalMeshDataInfo._effectiveMaterial = null;\n    this._instanceDataStorage.isFrozen = true;\n  }\n  /** @internal */\n  _unFreeze() {\n    this._instanceDataStorage.isFrozen = false;\n    this._instanceDataStorage.previousBatch = null;\n  }\n  /**\n   * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n   * @param subMesh defines the subMesh to render\n   * @param enableAlphaMode defines if alpha mode can be changed\n   * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n   * @returns the current mesh\n   */\n  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n    var _a, _b, _c;\n    const scene = this.getScene();\n    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n    } else {\n      this._internalAbstractMeshDataInfo._isActive = false;\n    }\n    if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n      return this;\n    }\n    // Managing instances\n    const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n    if (batch.mustReturn) {\n      return this;\n    }\n    // Checking geometry state\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n    const engine = scene.getEngine();\n    let oldCameraMaxZ = 0;\n    let oldCamera = null;\n    if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n      oldCameraMaxZ = scene.activeCamera.maxZ;\n      oldCamera = scene.activeCamera;\n      scene.activeCamera.maxZ = 0;\n      scene.updateTransformMatrix(true);\n    }\n    if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n    }\n    const renderingMesh = subMesh.getRenderingMesh();\n    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;\n    const instanceDataStorage = this._instanceDataStorage;\n    const material = subMesh.getMaterial();\n    if (!material) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    // Material\n    if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n      if (material._storeEffectOnSubMeshes) {\n        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n          if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n          }\n          return this;\n        }\n      } else if (!material.isReady(this, hardwareInstancedRendering)) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n        return this;\n      }\n      this._internalMeshDataInfo._effectiveMaterial = material;\n    } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    // Alpha mode\n    if (enableAlphaMode) {\n      engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n    }\n    let drawWrapper;\n    if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n      drawWrapper = subMesh._drawWrapper;\n    } else {\n      drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n    }\n    const effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;\n    for (const step of scene._beforeRenderingMeshStage) {\n      step.action(this, subMesh, batch, effect);\n    }\n    if (!drawWrapper || !effect) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    const effectiveMesh = effectiveMeshReplacement || this;\n    let sideOrientation;\n    if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n      const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n      sideOrientation = this.overrideMaterialSideOrientation;\n      if (sideOrientation == null) {\n        sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n      }\n      if (mainDeterminant < 0) {\n        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n      }\n      instanceDataStorage.sideOrientation = sideOrientation;\n    } else {\n      sideOrientation = instanceDataStorage.sideOrientation;\n    }\n    const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n    if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n      engine.setDepthWrite(true);\n    }\n    // Bind\n    const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n    const fillMode = effectiveMaterial.fillMode;\n    if (this._internalMeshDataInfo._onBeforeBindObservable) {\n      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n    }\n    if (!hardwareInstancedRendering) {\n      // Binding will be done later because we need to add more info to the VB\n      this._bind(subMesh, effect, fillMode, false);\n    }\n    const world = effectiveMesh.getWorldMatrix();\n    if (effectiveMaterial._storeEffectOnSubMeshes) {\n      effectiveMaterial.bindForSubMesh(world, this, subMesh);\n    } else {\n      effectiveMaterial.bind(world, this);\n    }\n    if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n      engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n      engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n      if (this._internalMeshDataInfo._onBetweenPassObservable) {\n        this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n      }\n    }\n    // Draw\n    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n    // Unbind\n    this._internalMeshDataInfo._effectiveMaterial.unbind();\n    for (const step of scene._afterRenderingMeshStage) {\n      step.action(this, subMesh, batch, effect);\n    }\n    if (this._internalMeshDataInfo._onAfterRenderObservable) {\n      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n    }\n    if (oldCamera) {\n      oldCamera.maxZ = oldCameraMaxZ;\n      scene.updateTransformMatrix(true);\n    }\n    if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {\n      this._freeze();\n    }\n    return this;\n  }\n  /**\n   *   Renormalize the mesh and patch it up if there are no weights\n   *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n   *   However in the case of zero weights then we set just a single influence to 1.\n   *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n   */\n  cleanMatrixWeights() {\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n        this._normalizeSkinWeightsAndExtra();\n      } else {\n        this._normalizeSkinFourWeights();\n      }\n    }\n  }\n  // faster 4 weight version.\n  _normalizeSkinFourWeights() {\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    const numWeights = matricesWeights.length;\n    for (let a = 0; a < numWeights; a += 4) {\n      // accumulate weights\n      const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        matricesWeights[a] = 1;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        matricesWeights[a] *= recip;\n        matricesWeights[a + 1] *= recip;\n        matricesWeights[a + 2] *= recip;\n        matricesWeights[a + 3] *= recip;\n      }\n    }\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n  }\n  // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n  _normalizeSkinWeightsAndExtra() {\n    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    const numWeights = matricesWeights.length;\n    for (let a = 0; a < numWeights; a += 4) {\n      // accumulate weights\n      let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        matricesWeights[a] = 1;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        matricesWeights[a] *= recip;\n        matricesWeights[a + 1] *= recip;\n        matricesWeights[a + 2] *= recip;\n        matricesWeights[a + 3] *= recip;\n        // same goes for extras\n        matricesWeightsExtra[a] *= recip;\n        matricesWeightsExtra[a + 1] *= recip;\n        matricesWeightsExtra[a + 2] *= recip;\n        matricesWeightsExtra[a + 3] *= recip;\n      }\n    }\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n  }\n  /**\n   * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n   * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n   * the user know there was an issue with importing the mesh\n   * @returns a validation object with skinned, valid and report string\n   */\n  validateSkinning() {\n    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    if (matricesWeights === null || this.skeleton == null) {\n      return {\n        skinned: false,\n        valid: true,\n        report: \"not skinned\"\n      };\n    }\n    const numWeights = matricesWeights.length;\n    let numberNotSorted = 0;\n    let missingWeights = 0;\n    let maxUsedWeights = 0;\n    let numberNotNormalized = 0;\n    const numInfluences = matricesWeightsExtra === null ? 4 : 8;\n    const usedWeightCounts = new Array();\n    for (let a = 0; a <= numInfluences; a++) {\n      usedWeightCounts[a] = 0;\n    }\n    const toleranceEpsilon = 0.001;\n    for (let a = 0; a < numWeights; a += 4) {\n      let lastWeight = matricesWeights[a];\n      let t = lastWeight;\n      let usedWeights = t === 0 ? 0 : 1;\n      for (let b = 1; b < numInfluences; b++) {\n        const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\n        if (d > lastWeight) {\n          numberNotSorted++;\n        }\n        if (d !== 0) {\n          usedWeights++;\n        }\n        t += d;\n        lastWeight = d;\n      }\n      // count the buffer weights usage\n      usedWeightCounts[usedWeights]++;\n      // max influences\n      if (usedWeights > maxUsedWeights) {\n        maxUsedWeights = usedWeights;\n      }\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        missingWeights++;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        let tolerance = 0;\n        for (let b = 0; b < numInfluences; b++) {\n          if (b < 4) {\n            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);\n          } else {\n            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);\n          }\n        }\n        // arbitrary epsilon value for dictating not normalized\n        if (tolerance > toleranceEpsilon) {\n          numberNotNormalized++;\n        }\n      }\n    }\n    // validate bone indices are in range of the skeleton\n    const numBones = this.skeleton.bones.length;\n    const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    let numBadBoneIndices = 0;\n    for (let a = 0; a < numWeights; a += 4) {\n      for (let b = 0; b < numInfluences; b++) {\n        const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\n        if (index >= numBones || index < 0) {\n          numBadBoneIndices++;\n        }\n      }\n    }\n    // log mesh stats\n    const output = \"Number of Weights = \" + numWeights / 4 + \"\\nMaximum influences = \" + maxUsedWeights + \"\\nMissing Weights = \" + missingWeights + \"\\nNot Sorted = \" + numberNotSorted + \"\\nNot Normalized = \" + numberNotNormalized + \"\\nWeightCounts = [\" + usedWeightCounts + \"]\" + \"\\nNumber of bones = \" + numBones + \"\\nBad Bone Indices = \" + numBadBoneIndices;\n    return {\n      skinned: true,\n      valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0,\n      report: output\n    };\n  }\n  /** @internal */\n  _checkDelayState() {\n    const scene = this.getScene();\n    if (this._geometry) {\n      this._geometry.load(scene);\n    } else if (this.delayLoadState === 4) {\n      this.delayLoadState = 2;\n      this._queueLoad(scene);\n    }\n    return this;\n  }\n  _queueLoad(scene) {\n    scene.addPendingData(this);\n    const getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n    Tools.LoadFile(this.delayLoadingFile, data => {\n      if (data instanceof ArrayBuffer) {\n        this._delayLoadingFunction(data, this);\n      } else {\n        this._delayLoadingFunction(JSON.parse(data), this);\n      }\n      this.instances.forEach(instance => {\n        instance.refreshBoundingInfo();\n        instance._syncSubMeshes();\n      });\n      this.delayLoadState = 1;\n      scene.removePendingData(this);\n    }, () => {}, scene.offlineProvider, getBinaryData);\n    return this;\n  }\n  /**\n   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n   * A mesh is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the mesh is in the frustum planes\n   */\n  isInFrustum(frustumPlanes) {\n    if (this.delayLoadState === 2) {\n      return false;\n    }\n    if (!super.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n    this._checkDelayState();\n    return true;\n  }\n  /**\n   * Sets the mesh material by the material or multiMaterial `id` property\n   * @param id is a string identifying the material or the multiMaterial\n   * @returns the current mesh\n   */\n  setMaterialById(id) {\n    const materials = this.getScene().materials;\n    let index;\n    for (index = materials.length - 1; index > -1; index--) {\n      if (materials[index].id === id) {\n        this.material = materials[index];\n        return this;\n      }\n    }\n    // Multi\n    const multiMaterials = this.getScene().multiMaterials;\n    for (index = multiMaterials.length - 1; index > -1; index--) {\n      if (multiMaterials[index].id === id) {\n        this.material = multiMaterials[index];\n        return this;\n      }\n    }\n    return this;\n  }\n  /**\n   * Returns as a new array populated with the mesh material and/or skeleton, if any.\n   * @returns an array of IAnimatable\n   */\n  getAnimatables() {\n    const results = new Array();\n    if (this.material) {\n      results.push(this.material);\n    }\n    if (this.skeleton) {\n      results.push(this.skeleton);\n    }\n    return results;\n  }\n  /**\n   * Modifies the mesh geometry according to the passed transformation matrix.\n   * This method returns nothing, but it really modifies the mesh even if it's originally not set as updatable.\n   * The mesh normals are modified using the same transformation.\n   * Note that, under the hood, this method sets a new VertexBuffer each call.\n   * @param transform defines the transform matrix to use\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   * @returns the current mesh\n   */\n  bakeTransformIntoVertices(transform) {\n    // Position\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      return this;\n    }\n    const submeshes = this.subMeshes.splice(0);\n    this._resetPointsArrayCache();\n    let data = this.getVerticesData(VertexBuffer.PositionKind);\n    const temp = Vector3.Zero();\n    let index;\n    for (index = 0; index < data.length; index += 3) {\n      Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);\n    }\n    this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\n    // Normals\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      data = this.getVerticesData(VertexBuffer.NormalKind);\n      for (index = 0; index < data.length; index += 3) {\n        Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);\n      }\n      this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n    }\n    // flip faces?\n    if (transform.determinant() < 0) {\n      this.flipFaces();\n    }\n    // Restore submeshes\n    this.releaseSubMeshes();\n    this.subMeshes = submeshes;\n    return this;\n  }\n  /**\n   * Modifies the mesh geometry according to its own current World Matrix.\n   * The mesh World Matrix is then reset.\n   * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n   * Note that, under the hood, this method sets a new VertexBuffer each call.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   * @param bakeIndependentlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n   * @returns the current mesh\n   */\n  bakeCurrentTransformIntoVertices() {\n    let bakeIndependentlyOfChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n    this.resetLocalMatrix(bakeIndependentlyOfChildren);\n    return this;\n  }\n  // Cache\n  /** @internal */\n  get _positions() {\n    if (this._internalAbstractMeshDataInfo._positions) {\n      return this._internalAbstractMeshDataInfo._positions;\n    }\n    if (this._geometry) {\n      return this._geometry._positions;\n    }\n    return null;\n  }\n  /** @internal */\n  _resetPointsArrayCache() {\n    if (this._geometry) {\n      this._geometry._resetPointsArrayCache();\n    }\n    return this;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    if (this._geometry) {\n      return this._geometry._generatePointsArray();\n    }\n    return false;\n  }\n  /**\n   * Returns a new Mesh object generated from the current mesh properties.\n   * This method must not get confused with createInstance()\n   * @param name is a string, the name given to the new mesh\n   * @param newParent can be any Node object (default `null`)\n   * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n   * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n   * @returns a new mesh\n   */\n  clone() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let doNotCloneChildren = arguments.length > 2 ? arguments[2] : undefined;\n    let clonePhysicsImpostor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n  }\n  /**\n   * Releases resources associated with this mesh.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse) {\n    let disposeMaterialAndTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.morphTargetManager = null;\n    if (this._geometry) {\n      this._geometry.releaseForMesh(this, true);\n    }\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (internalDataInfo._onBeforeDrawObservable) {\n      internalDataInfo._onBeforeDrawObservable.clear();\n    }\n    if (internalDataInfo._onBeforeBindObservable) {\n      internalDataInfo._onBeforeBindObservable.clear();\n    }\n    if (internalDataInfo._onBeforeRenderObservable) {\n      internalDataInfo._onBeforeRenderObservable.clear();\n    }\n    if (internalDataInfo._onAfterRenderObservable) {\n      internalDataInfo._onAfterRenderObservable.clear();\n    }\n    if (internalDataInfo._onBetweenPassObservable) {\n      internalDataInfo._onBetweenPassObservable.clear();\n    }\n    // Sources\n    if (this._scene.useClonedMeshMap) {\n      if (internalDataInfo.meshMap) {\n        for (const uniqueId in internalDataInfo.meshMap) {\n          const mesh = internalDataInfo.meshMap[uniqueId];\n          if (mesh) {\n            mesh._internalMeshDataInfo._source = null;\n            internalDataInfo.meshMap[uniqueId] = undefined;\n          }\n        }\n      }\n      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n      }\n    } else {\n      const meshes = this.getScene().meshes;\n      for (const abstractMesh of meshes) {\n        const mesh = abstractMesh;\n        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\n          mesh._internalMeshDataInfo._source = null;\n        }\n      }\n    }\n    internalDataInfo._source = null;\n    this._instanceDataStorage.visibleInstances = {};\n    // Instances\n    this._disposeInstanceSpecificData();\n    // Thin instances\n    this._disposeThinInstanceSpecificData();\n    if (this._internalMeshDataInfo._checkReadinessObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n    }\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /** @internal */\n  _disposeInstanceSpecificData() {\n    // Do nothing\n  }\n  /** @internal */\n  _disposeThinInstanceSpecificData() {\n    // Do nothing\n  }\n  /** @internal */\n  _invalidateInstanceVertexArrayObject() {\n    // Do nothing\n  }\n  /**\n   * Modifies the mesh geometry according to a displacement map.\n   * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n   * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n   * @param url is a string, the URL from the image file is to be downloaded.\n   * @param minHeight is the lower limit of the displacement.\n   * @param maxHeight is the upper limit of the displacement.\n   * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n   * @param uvOffset is an optional vector2 used to offset UV.\n   * @param uvScale is an optional vector2 used to scale UV.\n   * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n   * @returns the Mesh.\n   */\n  applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale) {\n    let forceUpdate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const scene = this.getScene();\n    const onload = img => {\n      // Getting height map data\n      const heightMapWidth = img.width;\n      const heightMapHeight = img.height;\n      const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(img, 0, 0);\n      // Create VertexData from map data\n      //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n      const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n      this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\n      //execute success callback, if set\n      if (onSuccess) {\n        onSuccess(this);\n      }\n    };\n    Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\n    return this;\n  }\n  /**\n   * Modifies the mesh geometry according to a displacementMap buffer.\n   * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n   * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n   * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n   * @param heightMapWidth is the width of the buffer image.\n   * @param heightMapHeight is the height of the buffer image.\n   * @param minHeight is the lower limit of the displacement.\n   * @param maxHeight is the upper limit of the displacement.\n   * @param uvOffset is an optional vector2 used to offset UV.\n   * @param uvScale is an optional vector2 used to scale UV.\n   * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n   * @returns the Mesh.\n   */\n  applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale) {\n    let forceUpdate = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n      return this;\n    }\n    const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n    const normals = this.getVerticesData(VertexBuffer.NormalKind);\n    const uvs = this.getVerticesData(VertexBuffer.UVKind);\n    let position = Vector3.Zero();\n    const normal = Vector3.Zero();\n    const uv = Vector2.Zero();\n    uvOffset = uvOffset || Vector2.Zero();\n    uvScale = uvScale || new Vector2(1, 1);\n    for (let index = 0; index < positions.length; index += 3) {\n      Vector3.FromArrayToRef(positions, index, position);\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);\n      // Compute height\n      const u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;\n      const v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;\n      const pos = (u + v * heightMapWidth) * 4;\n      const r = buffer[pos] / 255.0;\n      const g = buffer[pos + 1] / 255.0;\n      const b = buffer[pos + 2] / 255.0;\n      const gradient = r * 0.3 + g * 0.59 + b * 0.11;\n      normal.normalize();\n      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n      position = position.add(normal);\n      position.toArray(positions, index);\n    }\n    VertexData.ComputeNormals(positions, this.getIndices(), normals);\n    if (forceUpdate) {\n      this.setVerticesData(VertexBuffer.PositionKind, positions);\n      this.setVerticesData(VertexBuffer.NormalKind, normals);\n      this.setVerticesData(VertexBuffer.UVKind, uvs);\n    } else {\n      this.updateVerticesData(VertexBuffer.PositionKind, positions);\n      this.updateVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    return this;\n  }\n  /**\n   * Modify the mesh to get a flat shading rendering.\n   * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n   * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n   * @returns current mesh\n   */\n  convertToFlatShadedMesh() {\n    const kinds = this.getVerticesDataKinds();\n    const vbs = {};\n    const data = {};\n    const newdata = {};\n    let updatableNormals = false;\n    let kindIndex;\n    let kind;\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      const vertexBuffer = this.getVertexBuffer(kind);\n      // Check data consistency\n      const vertexData = vertexBuffer.getData();\n      if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n        if (vertexData.length === 0) {\n          continue;\n        }\n      }\n      if (kind === VertexBuffer.NormalKind) {\n        updatableNormals = vertexBuffer.isUpdatable();\n        kinds.splice(kindIndex, 1);\n        kindIndex--;\n        continue;\n      }\n      vbs[kind] = vertexBuffer;\n      data[kind] = this.getVerticesData(kind);\n      newdata[kind] = [];\n    }\n    // Save previous submeshes\n    const previousSubmeshes = this.subMeshes.slice(0);\n    const indices = this.getIndices();\n    const totalIndices = this.getTotalIndices();\n    // Generating unique vertices per face\n    let index;\n    for (index = 0; index < totalIndices; index++) {\n      const vertexIndex = indices[index];\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        if (!vbs[kind]) {\n          continue;\n        }\n        const stride = vbs[kind].getStrideSize();\n        for (let offset = 0; offset < stride; offset++) {\n          newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n        }\n      }\n    }\n    // Updating faces & normal\n    const normals = [];\n    const positions = newdata[VertexBuffer.PositionKind];\n    const useRightHandedSystem = this.getScene().useRightHandedSystem;\n    let flipNormalGeneration;\n    if (useRightHandedSystem) {\n      flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n    } else {\n      flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n    }\n    for (index = 0; index < totalIndices; index += 3) {\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n      indices[index + 2] = index + 2;\n      const p1 = Vector3.FromArray(positions, index * 3);\n      const p2 = Vector3.FromArray(positions, (index + 1) * 3);\n      const p3 = Vector3.FromArray(positions, (index + 2) * 3);\n      const p1p2 = p1.subtract(p2);\n      const p3p2 = p3.subtract(p2);\n      const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n      if (flipNormalGeneration) {\n        normal.scaleInPlace(-1);\n      }\n      // Store same normals for every vertex\n      for (let localIndex = 0; localIndex < 3; localIndex++) {\n        normals.push(normal.x);\n        normals.push(normal.y);\n        normals.push(normal.z);\n      }\n    }\n    this.setIndices(indices);\n    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\n    // Updating vertex buffers\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      if (!newdata[kind]) {\n        continue;\n      }\n      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n    }\n    // Updating submeshes\n    this.releaseSubMeshes();\n    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n      const previousOne = previousSubmeshes[submeshIndex];\n      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n    }\n    this.synchronizeInstances();\n    return this;\n  }\n  /**\n   * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n   * In other words, more vertices, no more indices and a single bigger VBO.\n   * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n   * @returns current mesh\n   */\n  convertToUnIndexedMesh() {\n    const kinds = this.getVerticesDataKinds();\n    const vbs = {};\n    const data = {};\n    const newdata = {};\n    let kindIndex;\n    let kind;\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      const vertexBuffer = this.getVertexBuffer(kind);\n      vbs[kind] = vertexBuffer;\n      data[kind] = vbs[kind].getData();\n      newdata[kind] = [];\n    }\n    // Save previous submeshes\n    const previousSubmeshes = this.subMeshes.slice(0);\n    const indices = this.getIndices();\n    const totalIndices = this.getTotalIndices();\n    // Generating unique vertices per face\n    let index;\n    for (index = 0; index < totalIndices; index++) {\n      const vertexIndex = indices[index];\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        const stride = vbs[kind].getStrideSize();\n        for (let offset = 0; offset < stride; offset++) {\n          newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n        }\n      }\n    }\n    // Updating indices\n    for (index = 0; index < totalIndices; index += 3) {\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n      indices[index + 2] = index + 2;\n    }\n    this.setIndices(indices);\n    // Updating vertex buffers\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());\n    }\n    // Updating submeshes\n    this.releaseSubMeshes();\n    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n      const previousOne = previousSubmeshes[submeshIndex];\n      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n    }\n    this._unIndexed = true;\n    this.synchronizeInstances();\n    return this;\n  }\n  /**\n   * Inverses facet orientations.\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   * @param flipNormals will also inverts the normals\n   * @returns current mesh\n   */\n  flipFaces() {\n    let flipNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    let i;\n    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n      for (i = 0; i < vertex_data.normals.length; i++) {\n        vertex_data.normals[i] *= -1;\n      }\n    }\n    if (vertex_data.indices) {\n      let temp;\n      for (i = 0; i < vertex_data.indices.length; i += 3) {\n        // reassign indices\n        temp = vertex_data.indices[i + 1];\n        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n        vertex_data.indices[i + 2] = temp;\n      }\n    }\n    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    return this;\n  }\n  /**\n   * Increase the number of facets and hence vertices in a mesh\n   * Vertex normals are interpolated from existing vertex normals\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n   */\n  increaseVertices() {\n    let numberPerEdge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n    const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n    const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n    const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n    if (!currentIndices || !positions) {\n      Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n    } else {\n      vertex_data.indices = currentIndices;\n      vertex_data.positions = positions;\n      if (uvs) {\n        vertex_data.uvs = uvs;\n      }\n      if (normals) {\n        vertex_data.normals = normals;\n      }\n      const segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n      const tempIndices = new Array();\n      for (let i = 0; i < segments + 1; i++) {\n        tempIndices[i] = new Array();\n      }\n      let a; //vertex index of one end of a side\n      let b; //vertex index of other end of the side\n      const deltaPosition = new Vector3(0, 0, 0);\n      const deltaNormal = new Vector3(0, 0, 0);\n      const deltaUV = new Vector2(0, 0);\n      const indices = new Array();\n      const vertexIndex = new Array();\n      const side = new Array();\n      let len;\n      let positionPtr = positions.length;\n      let uvPtr;\n      if (uvs) {\n        uvPtr = uvs.length;\n      }\n      let normalsPtr;\n      if (normals) {\n        normalsPtr = normals.length;\n      }\n      for (let i = 0; i < currentIndices.length; i += 3) {\n        vertexIndex[0] = currentIndices[i];\n        vertexIndex[1] = currentIndices[i + 1];\n        vertexIndex[2] = currentIndices[i + 2];\n        for (let j = 0; j < 3; j++) {\n          a = vertexIndex[j];\n          b = vertexIndex[(j + 1) % 3];\n          if (side[a] === undefined && side[b] === undefined) {\n            side[a] = new Array();\n            side[b] = new Array();\n          } else {\n            if (side[a] === undefined) {\n              side[a] = new Array();\n            }\n            if (side[b] === undefined) {\n              side[b] = new Array();\n            }\n          }\n          if (side[a][b] === undefined && side[b][a] === undefined) {\n            side[a][b] = [];\n            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n            if (normals) {\n              deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n              deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n              deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n            }\n            if (uvs) {\n              deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n              deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n            }\n            side[a][b].push(a);\n            for (let k = 1; k < segments; k++) {\n              side[a][b].push(positions.length / 3);\n              positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n              positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n              positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n              if (normals) {\n                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n              }\n              if (uvs) {\n                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n              }\n            }\n            side[a][b].push(b);\n            side[b][a] = new Array();\n            len = side[a][b].length;\n            for (let idx = 0; idx < len; idx++) {\n              side[b][a][idx] = side[a][b][len - 1 - idx];\n            }\n          }\n        }\n        //Calculate positions, normals and uvs of new internal vertices\n        tempIndices[0][0] = currentIndices[i];\n        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\n        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\n        for (let k = 2; k < segments; k++) {\n          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\n          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\n          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\n          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\n          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\n          if (normals) {\n            deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\n            deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\n            deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\n          }\n          if (uvs) {\n            deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\n            deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\n          }\n          for (let j = 1; j < k; j++) {\n            tempIndices[k][j] = positions.length / 3;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\n            if (normals) {\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\n            }\n            if (uvs) {\n              uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\n              uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\n            }\n          }\n        }\n        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\n        // reform indices\n        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n        for (let k = 1; k < segments; k++) {\n          let j;\n          for (j = 0; j < k; j++) {\n            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\n          }\n          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n        }\n      }\n      vertex_data.indices = indices;\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    }\n  }\n  /**\n   * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n   * This will undo any application of covertToFlatShadedMesh\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   */\n  forceSharedVertices() {\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    const currentUVs = vertex_data.uvs;\n    const currentIndices = vertex_data.indices;\n    const currentPositions = vertex_data.positions;\n    const currentColors = vertex_data.colors;\n    const currentMatrixIndices = vertex_data.matricesIndices;\n    const currentMatrixWeights = vertex_data.matricesWeights;\n    const currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;\n    const currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;\n    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n      Logger.Warn(\"VertexData contains empty entries\");\n    } else {\n      const positions = new Array();\n      const indices = new Array();\n      const uvs = new Array();\n      const colors = new Array();\n      const matrixIndices = new Array();\n      const matrixWeights = new Array();\n      const matrixIndicesExtra = new Array();\n      const matrixWeightsExtra = new Array();\n      let pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n      let indexPtr = 0; // pointer to next available index value\n      const uniquePositions = {}; // unique vertex positions\n      let ptr; // pointer to element in uniquePositions\n      let facet;\n      for (let i = 0; i < currentIndices.length; i += 3) {\n        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n        pstring = new Array();\n        for (let j = 0; j < 3; j++) {\n          pstring[j] = \"\";\n          for (let k = 0; k < 3; k++) {\n            //small values make 0\n            if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n              currentPositions[3 * facet[j] + k] = 0;\n            }\n            pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n          }\n        }\n        //check facet vertices to see that none are repeated\n        // do not process any facet that has a repeated vertex, ie is a line\n        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n          //for each facet position check if already listed in uniquePositions\n          // if not listed add to uniquePositions and set index pointer\n          // if listed use its index in uniquePositions and new index pointer\n          for (let j = 0; j < 3; j++) {\n            ptr = uniquePositions[pstring[j]];\n            if (ptr === undefined) {\n              uniquePositions[pstring[j]] = indexPtr;\n              ptr = indexPtr++;\n              //not listed so add individual x, y, z coordinates to positions\n              for (let k = 0; k < 3; k++) {\n                positions.push(currentPositions[3 * facet[j] + k]);\n              }\n              if (currentColors !== null && currentColors !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  colors.push(currentColors[4 * facet[j] + k]);\n                }\n              }\n              if (currentUVs !== null && currentUVs !== void 0) {\n                for (let k = 0; k < 2; k++) {\n                  uvs.push(currentUVs[2 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);\n                }\n              }\n            }\n            // add new index pointer to indices array\n            indices.push(ptr);\n          }\n        }\n      }\n      const normals = new Array();\n      VertexData.ComputeNormals(positions, indices, normals);\n      //create new vertex data object and update\n      vertex_data.positions = positions;\n      vertex_data.indices = indices;\n      vertex_data.normals = normals;\n      if (currentUVs !== null && currentUVs !== void 0) {\n        vertex_data.uvs = uvs;\n      }\n      if (currentColors !== null && currentColors !== void 0) {\n        vertex_data.colors = colors;\n      }\n      if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n        vertex_data.matricesIndices = matrixIndices;\n      }\n      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n        vertex_data.matricesWeights = matrixWeights;\n      }\n      if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n        vertex_data.matricesIndicesExtra = matrixIndicesExtra;\n      }\n      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n        vertex_data.matricesWeightsExtra = matrixWeightsExtra;\n      }\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    }\n  }\n  // Instances\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n  static _instancedMeshFactory(name, mesh) {\n    throw _WarnImport(\"InstancedMesh\");\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _PhysicsImpostorParser(scene, physicObject, jsonObject) {\n    throw _WarnImport(\"PhysicsImpostor\");\n  }\n  /**\n   * Creates a new InstancedMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedMesh\n   */\n  createInstance(name) {\n    return Mesh._instancedMeshFactory(name, this);\n  }\n  /**\n   * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n   * After this call, all the mesh instances have the same submeshes than the current mesh.\n   * @returns the current mesh\n   */\n  synchronizeInstances() {\n    for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n      const instance = this.instances[instanceIndex];\n      instance._syncSubMeshes();\n    }\n    return this;\n  }\n  /**\n   * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n   * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n   * This should be used together with the simplification to avoid disappearing triangles.\n   * @param successCallback an optional success callback to be called after the optimization finished.\n   * @returns the current mesh\n   */\n  optimizeIndices(successCallback) {\n    const indices = this.getIndices();\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions || !indices) {\n      return this;\n    }\n    const vectorPositions = new Array();\n    for (let pos = 0; pos < positions.length; pos = pos + 3) {\n      vectorPositions.push(Vector3.FromArray(positions, pos));\n    }\n    const dupes = new Array();\n    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, iteration => {\n      const realPos = vectorPositions.length - 1 - iteration;\n      const testedPosition = vectorPositions[realPos];\n      for (let j = 0; j < realPos; ++j) {\n        const againstPosition = vectorPositions[j];\n        if (testedPosition.equals(againstPosition)) {\n          dupes[realPos] = j;\n          break;\n        }\n      }\n    }, () => {\n      for (let i = 0; i < indices.length; ++i) {\n        indices[i] = dupes[indices[i]] || indices[i];\n      }\n      //indices are now reordered\n      const originalSubMeshes = this.subMeshes.slice(0);\n      this.setIndices(indices);\n      this.subMeshes = originalSubMeshes;\n      if (successCallback) {\n        successCallback(this);\n      }\n    });\n    return this;\n  }\n  /**\n   * Serialize current mesh\n   * @param serializationObject defines the object which will receive the serialization data\n   */\n  serialize() {\n    let serializationObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.type = this.getClassName();\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    serializationObject.position = this.position.asArray();\n    if (this.rotationQuaternion) {\n      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n    } else if (this.rotation) {\n      serializationObject.rotation = this.rotation.asArray();\n    }\n    serializationObject.scaling = this.scaling.asArray();\n    if (this._postMultiplyPivotMatrix) {\n      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n    } else {\n      serializationObject.localMatrix = this.getPivotMatrix().asArray();\n    }\n    serializationObject.isEnabled = this.isEnabled(false);\n    serializationObject.isVisible = this.isVisible;\n    serializationObject.infiniteDistance = this.infiniteDistance;\n    serializationObject.pickable = this.isPickable;\n    serializationObject.receiveShadows = this.receiveShadows;\n    serializationObject.billboardMode = this.billboardMode;\n    serializationObject.visibility = this.visibility;\n    serializationObject.checkCollisions = this.checkCollisions;\n    serializationObject.isBlocker = this.isBlocker;\n    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    // Geometry\n    serializationObject.isUnIndexed = this.isUnIndexed;\n    const geometry = this._geometry;\n    if (geometry && this.subMeshes) {\n      serializationObject.geometryUniqueId = geometry.uniqueId;\n      serializationObject.geometryId = geometry.id;\n      // SubMeshes\n      serializationObject.subMeshes = [];\n      for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n        const subMesh = this.subMeshes[subIndex];\n        serializationObject.subMeshes.push({\n          materialIndex: subMesh.materialIndex,\n          verticesStart: subMesh.verticesStart,\n          verticesCount: subMesh.verticesCount,\n          indexStart: subMesh.indexStart,\n          indexCount: subMesh.indexCount\n        });\n      }\n    }\n    // Material\n    if (this.material) {\n      if (!this.material.doNotSerialize) {\n        serializationObject.materialUniqueId = this.material.uniqueId;\n        serializationObject.materialId = this.material.id; // back compat\n      }\n    } else {\n      this.material = null;\n      serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n      serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n    }\n    // Morph targets\n    if (this.morphTargetManager) {\n      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n    }\n    // Skeleton\n    if (this.skeleton) {\n      serializationObject.skeletonId = this.skeleton.id;\n      serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n    }\n    // Physics\n    //TODO implement correct serialization for physics impostors.\n    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n      const impostor = this.getPhysicsImpostor();\n      if (impostor) {\n        serializationObject.physicsMass = impostor.getParam(\"mass\");\n        serializationObject.physicsFriction = impostor.getParam(\"friction\");\n        serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n        serializationObject.physicsImpostor = impostor.type;\n      }\n    }\n    // Metadata\n    if (this.metadata) {\n      serializationObject.metadata = this.metadata;\n    }\n    // Instances\n    serializationObject.instances = [];\n    for (let index = 0; index < this.instances.length; index++) {\n      const instance = this.instances[index];\n      if (instance.doNotSerialize) {\n        continue;\n      }\n      const serializationInstance = {\n        name: instance.name,\n        id: instance.id,\n        isEnabled: instance.isEnabled(false),\n        isVisible: instance.isVisible,\n        isPickable: instance.isPickable,\n        checkCollisions: instance.checkCollisions,\n        position: instance.position.asArray(),\n        scaling: instance.scaling.asArray()\n      };\n      if (instance.parent) {\n        instance.parent._serializeAsParent(serializationInstance);\n      }\n      if (instance.rotationQuaternion) {\n        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n      } else if (instance.rotation) {\n        serializationInstance.rotation = instance.rotation.asArray();\n      }\n      // Physics\n      //TODO implement correct serialization for physics impostors.\n      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n        const impostor = instance.getPhysicsImpostor();\n        if (impostor) {\n          serializationInstance.physicsMass = impostor.getParam(\"mass\");\n          serializationInstance.physicsFriction = impostor.getParam(\"friction\");\n          serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\n          serializationInstance.physicsImpostor = impostor.type;\n        }\n      }\n      // Metadata\n      if (instance.metadata) {\n        serializationInstance.metadata = instance.metadata;\n      }\n      // Action Manager\n      if (instance.actionManager) {\n        serializationInstance.actions = instance.actionManager.serialize(instance.name);\n      }\n      serializationObject.instances.push(serializationInstance);\n      // Animations\n      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n      serializationInstance.ranges = instance.serializeAnimationRanges();\n    }\n    // Thin instances\n    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n      serializationObject.thinInstances = {\n        instancesCount: this._thinInstanceDataStorage.instancesCount,\n        matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n        enablePicking: this.thinInstanceEnablePicking\n      };\n      if (this._userThinInstanceBuffersStorage) {\n        const userThinInstance = {\n          data: {},\n          sizes: {},\n          strides: {}\n        };\n        for (const kind in this._userThinInstanceBuffersStorage.data) {\n          userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n        }\n        serializationObject.thinInstances.userThinInstance = userThinInstance;\n      }\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    // Layer mask\n    serializationObject.layerMask = this.layerMask;\n    // Alpha\n    serializationObject.alphaIndex = this.alphaIndex;\n    serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n    // Overlay\n    serializationObject.overlayAlpha = this.overlayAlpha;\n    serializationObject.overlayColor = this.overlayColor.asArray();\n    serializationObject.renderOverlay = this.renderOverlay;\n    // Fog\n    serializationObject.applyFog = this.applyFog;\n    // Action Manager\n    if (this.actionManager) {\n      serializationObject.actions = this.actionManager.serialize(this.name);\n    }\n    return serializationObject;\n  }\n  /** @internal */\n  _syncGeometryWithMorphTargetManager() {\n    if (!this.geometry) {\n      return;\n    }\n    this._markSubMeshesAsAttributesDirty();\n    const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n    if (morphTargetManager && morphTargetManager.vertexCount) {\n      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n        Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n        this.morphTargetManager = null;\n        return;\n      }\n      if (morphTargetManager.isUsingTextureForTargets) {\n        return;\n      }\n      for (let index = 0; index < morphTargetManager.numInfluencers; index++) {\n        const morphTarget = morphTargetManager.getActiveTarget(index);\n        const positions = morphTarget.getPositions();\n        if (!positions) {\n          Logger.Error(\"Invalid morph target. Target must have positions.\");\n          return;\n        }\n        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n        const normals = morphTarget.getNormals();\n        if (normals) {\n          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n        }\n        const tangents = morphTarget.getTangents();\n        if (tangents) {\n          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n        }\n        const uvs = morphTarget.getUVs();\n        if (uvs) {\n          this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n        }\n      }\n    } else {\n      let index = 0;\n      // Positions\n      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\n        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\n        }\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\n        }\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\n        }\n        index++;\n      }\n    }\n  }\n  /**\n   * Returns a new Mesh object parsed from the source provided.\n   * @param parsedMesh is the source\n   * @param scene defines the hosting scene\n   * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n   * @returns a new Mesh\n   */\n  static Parse(parsedMesh, scene, rootUrl) {\n    let mesh;\n    if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n      mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n    } else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n      mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n    } else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n      mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n    } else {\n      mesh = new Mesh(parsedMesh.name, scene);\n    }\n    mesh.id = parsedMesh.id;\n    mesh._waitingParsedUniqueId = parsedMesh.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(mesh, parsedMesh.tags);\n    }\n    mesh.position = Vector3.FromArray(parsedMesh.position);\n    if (parsedMesh.metadata !== undefined) {\n      mesh.metadata = parsedMesh.metadata;\n    }\n    if (parsedMesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n    } else if (parsedMesh.rotation) {\n      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n    }\n    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n    if (parsedMesh.localMatrix) {\n      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n    } else if (parsedMesh.pivotMatrix) {\n      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n    }\n    mesh.setEnabled(parsedMesh.isEnabled);\n    mesh.isVisible = parsedMesh.isVisible;\n    mesh.infiniteDistance = parsedMesh.infiniteDistance;\n    mesh.showBoundingBox = parsedMesh.showBoundingBox;\n    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n    if (parsedMesh.applyFog !== undefined) {\n      mesh.applyFog = parsedMesh.applyFog;\n    }\n    if (parsedMesh.pickable !== undefined) {\n      mesh.isPickable = parsedMesh.pickable;\n    }\n    if (parsedMesh.alphaIndex !== undefined) {\n      mesh.alphaIndex = parsedMesh.alphaIndex;\n    }\n    mesh.receiveShadows = parsedMesh.receiveShadows;\n    if (parsedMesh.billboardMode !== undefined) {\n      mesh.billboardMode = parsedMesh.billboardMode;\n    }\n    if (parsedMesh.visibility !== undefined) {\n      mesh.visibility = parsedMesh.visibility;\n    }\n    mesh.checkCollisions = parsedMesh.checkCollisions;\n    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n    if (parsedMesh.isBlocker !== undefined) {\n      mesh.isBlocker = parsedMesh.isBlocker;\n    }\n    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n    // freezeWorldMatrix\n    if (parsedMesh.freezeWorldMatrix) {\n      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n    }\n    // Parent\n    if (parsedMesh.parentId !== undefined) {\n      mesh._waitingParentId = parsedMesh.parentId;\n    }\n    if (parsedMesh.parentInstanceIndex !== undefined) {\n      mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;\n    }\n    // Actions\n    if (parsedMesh.actions !== undefined) {\n      mesh._waitingData.actions = parsedMesh.actions;\n    }\n    // Overlay\n    if (parsedMesh.overlayAlpha !== undefined) {\n      mesh.overlayAlpha = parsedMesh.overlayAlpha;\n    }\n    if (parsedMesh.overlayColor !== undefined) {\n      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n    }\n    if (parsedMesh.renderOverlay !== undefined) {\n      mesh.renderOverlay = parsedMesh.renderOverlay;\n    }\n    // Geometry\n    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n    if (parsedMesh.delayLoadingFile) {\n      mesh.delayLoadState = 4;\n      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n      mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n      if (parsedMesh._binaryInfo) {\n        mesh._binaryInfo = parsedMesh._binaryInfo;\n      }\n      mesh._delayInfo = [];\n      if (parsedMesh.hasUVs) {\n        mesh._delayInfo.push(VertexBuffer.UVKind);\n      }\n      if (parsedMesh.hasUVs2) {\n        mesh._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n      if (parsedMesh.hasUVs3) {\n        mesh._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n      if (parsedMesh.hasUVs4) {\n        mesh._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n      if (parsedMesh.hasUVs5) {\n        mesh._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n      if (parsedMesh.hasUVs6) {\n        mesh._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n      if (parsedMesh.hasColors) {\n        mesh._delayInfo.push(VertexBuffer.ColorKind);\n      }\n      if (parsedMesh.hasMatricesIndices) {\n        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n      if (parsedMesh.hasMatricesWeights) {\n        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n      mesh._delayLoadingFunction = Geometry._ImportGeometry;\n      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n        mesh._checkDelayState();\n      }\n    } else {\n      Geometry._ImportGeometry(parsedMesh, mesh);\n    }\n    // Material\n    if (parsedMesh.materialUniqueId) {\n      mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n    } else if (parsedMesh.materialId) {\n      mesh._waitingMaterialId = parsedMesh.materialId;\n    }\n    // Morph targets\n    if (parsedMesh.morphTargetManagerId > -1) {\n      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n    }\n    // Skeleton\n    if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n      mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n      if (parsedMesh.numBoneInfluencers) {\n        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n      }\n    }\n    // Animations\n    if (parsedMesh.animations) {\n      for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n        const parsedAnimation = parsedMesh.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          mesh.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n    }\n    if (parsedMesh.autoAnimate) {\n      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n    }\n    // Layer Mask\n    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n    } else {\n      mesh.layerMask = 0x0fffffff;\n    }\n    // Physics\n    if (parsedMesh.physicsImpostor) {\n      Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n    }\n    // Levels\n    if (parsedMesh.lodMeshIds) {\n      mesh._waitingData.lods = {\n        ids: parsedMesh.lodMeshIds,\n        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null\n      };\n    }\n    // Instances\n    if (parsedMesh.instances) {\n      for (let index = 0; index < parsedMesh.instances.length; index++) {\n        const parsedInstance = parsedMesh.instances[index];\n        const instance = mesh.createInstance(parsedInstance.name);\n        if (parsedInstance.id) {\n          instance.id = parsedInstance.id;\n        }\n        if (Tags) {\n          if (parsedInstance.tags) {\n            Tags.AddTagsTo(instance, parsedInstance.tags);\n          } else {\n            Tags.AddTagsTo(instance, parsedMesh.tags);\n          }\n        }\n        instance.position = Vector3.FromArray(parsedInstance.position);\n        if (parsedInstance.metadata !== undefined) {\n          instance.metadata = parsedInstance.metadata;\n        }\n        if (parsedInstance.parentId !== undefined) {\n          instance._waitingParentId = parsedInstance.parentId;\n        }\n        if (parsedInstance.parentInstanceIndex !== undefined) {\n          instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;\n        }\n        if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n          instance.setEnabled(parsedInstance.isEnabled);\n        }\n        if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n          instance.isVisible = parsedInstance.isVisible;\n        }\n        if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n          instance.isPickable = parsedInstance.isPickable;\n        }\n        if (parsedInstance.rotationQuaternion) {\n          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n        } else if (parsedInstance.rotation) {\n          instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n        }\n        instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n        if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n          instance.checkCollisions = parsedInstance.checkCollisions;\n        }\n        if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n          instance.isPickable = parsedInstance.pickable;\n        }\n        if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n          instance.showBoundingBox = parsedInstance.showBoundingBox;\n        }\n        if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n        }\n        if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n          instance.alphaIndex = parsedInstance.alphaIndex;\n        }\n        // Physics\n        if (parsedInstance.physicsImpostor) {\n          Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n        }\n        // Actions\n        if (parsedInstance.actions !== undefined) {\n          instance._waitingData.actions = parsedInstance.actions;\n        }\n        // Animation\n        if (parsedInstance.animations) {\n          for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\n            const parsedAnimation = parsedInstance.animations[animationIndex];\n            const internalClass = GetClass(\"BABYLON.Animation\");\n            if (internalClass) {\n              instance.animations.push(internalClass.Parse(parsedAnimation));\n            }\n          }\n          Node.ParseAnimationRanges(instance, parsedInstance, scene);\n          if (parsedInstance.autoAnimate) {\n            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n          }\n        }\n      }\n    }\n    // Thin instances\n    if (parsedMesh.thinInstances) {\n      const thinInstances = parsedMesh.thinInstances;\n      mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n      if (thinInstances.matrixData) {\n        mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n      } else {\n        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n      }\n      if (parsedMesh.thinInstances.userThinInstance) {\n        const userThinInstance = parsedMesh.thinInstances.userThinInstance;\n        for (const kind in userThinInstance.data) {\n          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n        }\n      }\n    }\n    return mesh;\n  }\n  // Skeletons\n  /**\n   * Prepare internal position array for software CPU skinning\n   * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n   */\n  setPositionsForCPUSkinning() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourcePositions) {\n      const source = this.getVerticesData(VertexBuffer.PositionKind);\n      if (!source) {\n        return internalDataInfo._sourcePositions;\n      }\n      internalDataInfo._sourcePositions = new Float32Array(source);\n      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        this.setVerticesData(VertexBuffer.PositionKind, source, true);\n      }\n    }\n    return internalDataInfo._sourcePositions;\n  }\n  /**\n   * Prepare internal normal array for software CPU skinning\n   * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n   */\n  setNormalsForCPUSkinning() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourceNormals) {\n      const source = this.getVerticesData(VertexBuffer.NormalKind);\n      if (!source) {\n        return internalDataInfo._sourceNormals;\n      }\n      internalDataInfo._sourceNormals = new Float32Array(source);\n      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        this.setVerticesData(VertexBuffer.NormalKind, source, true);\n      }\n    }\n    return internalDataInfo._sourceNormals;\n  }\n  /**\n   * Updates the vertex buffer by applying transformation from the bones\n   * @param skeleton defines the skeleton to apply to current mesh\n   * @returns the current mesh\n   */\n  applySkeleton(skeleton) {\n    if (!this.geometry) {\n      return this;\n    }\n    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n      return this;\n    }\n    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      return this;\n    }\n    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      return this;\n    }\n    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      return this;\n    }\n    const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourcePositions) {\n      const submeshes = this.subMeshes.slice();\n      this.setPositionsForCPUSkinning();\n      this.subMeshes = submeshes;\n    }\n    if (hasNormals && !internalDataInfo._sourceNormals) {\n      this.setNormalsForCPUSkinning();\n    }\n    // positionsData checks for not being Float32Array will only pass at most once\n    let positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positionsData) {\n      return this;\n    }\n    if (!(positionsData instanceof Float32Array)) {\n      positionsData = new Float32Array(positionsData);\n    }\n    // normalsData checks for not being Float32Array will only pass at most once\n    let normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n    if (hasNormals) {\n      if (!normalsData) {\n        return this;\n      }\n      if (!(normalsData instanceof Float32Array)) {\n        normalsData = new Float32Array(normalsData);\n      }\n    }\n    const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    if (!matricesWeightsData || !matricesIndicesData) {\n      return this;\n    }\n    const needExtras = this.numBoneInfluencers > 4;\n    const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n    const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n    const skeletonMatrices = skeleton.getTransformMatrices(this);\n    const tempVector3 = Vector3.Zero();\n    const finalMatrix = new Matrix();\n    const tempMatrix = new Matrix();\n    let matWeightIdx = 0;\n    let inf;\n    for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n      let weight;\n      for (inf = 0; inf < 4; inf++) {\n        weight = matricesWeightsData[matWeightIdx + inf];\n        if (weight > 0) {\n          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n          finalMatrix.addToSelf(tempMatrix);\n        }\n      }\n      if (needExtras) {\n        for (inf = 0; inf < 4; inf++) {\n          weight = matricesWeightsExtraData[matWeightIdx + inf];\n          if (weight > 0) {\n            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n            finalMatrix.addToSelf(tempMatrix);\n          }\n        }\n      }\n      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n      tempVector3.toArray(positionsData, index);\n      if (hasNormals) {\n        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n        tempVector3.toArray(normalsData, index);\n      }\n      finalMatrix.reset();\n    }\n    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n    if (hasNormals) {\n      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n    }\n    return this;\n  }\n  // Tools\n  /**\n   * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n   * @param meshes defines the list of meshes to scan\n   * @returns an object `{min:` Vector3`, max:` Vector3`}`\n   */\n  static MinMax(meshes) {\n    let minVector = null;\n    let maxVector = null;\n    meshes.forEach(function (mesh) {\n      const boundingInfo = mesh.getBoundingInfo();\n      const boundingBox = boundingInfo.boundingBox;\n      if (!minVector || !maxVector) {\n        minVector = boundingBox.minimumWorld;\n        maxVector = boundingBox.maximumWorld;\n      } else {\n        minVector.minimizeInPlace(boundingBox.minimumWorld);\n        maxVector.maximizeInPlace(boundingBox.maximumWorld);\n      }\n    });\n    if (!minVector || !maxVector) {\n      return {\n        min: Vector3.Zero(),\n        max: Vector3.Zero()\n      };\n    }\n    return {\n      min: minVector,\n      max: maxVector\n    };\n  }\n  /**\n   * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n   * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n   * @returns a vector3\n   */\n  static Center(meshesOrMinMaxVector) {\n    const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n    return Vector3.Center(minMaxVector.min, minMaxVector.max);\n  }\n  /**\n   * Merge the array of meshes into a single mesh for performance reasons.\n   * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n   * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n   * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n   * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n   * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n   * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n   * @returns a new mesh\n   */\n  static MergeMeshes(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n  }\n  /**\n   * Merge the array of meshes into a single mesh for performance reasons.\n   * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n   * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n   * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n   * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n   * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n   * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n   * @returns a new mesh\n   */\n  static MergeMeshesAsync(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n  }\n  static _MergeMeshesCoroutine(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    let isAsync = arguments.length > 6 ? arguments[6] : undefined;\n    return function* () {\n      // Remove any null/undefined entries from the mesh array\n      meshes = meshes.filter(Boolean);\n      if (meshes.length === 0) {\n        return null;\n      }\n      let index;\n      if (!allow32BitsIndices) {\n        let totalVertices = 0;\n        // Counting vertices\n        for (index = 0; index < meshes.length; index++) {\n          totalVertices += meshes[index].getTotalVertices();\n          if (totalVertices >= 65536) {\n            Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n            return null;\n          }\n        }\n      }\n      if (multiMultiMaterials) {\n        subdivideWithSubMeshes = false;\n      }\n      const materialArray = new Array();\n      const materialIndexArray = new Array();\n      // Merge\n      const indiceArray = new Array();\n      const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n      for (index = 0; index < meshes.length; index++) {\n        const mesh = meshes[index];\n        if (mesh.isAnInstance) {\n          Logger.Warn(\"Cannot merge instance meshes.\");\n          return null;\n        }\n        if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {\n          Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n          return null;\n        }\n        if (subdivideWithSubMeshes) {\n          indiceArray.push(mesh.getTotalIndices());\n        }\n        if (multiMultiMaterials) {\n          if (mesh.material) {\n            const material = mesh.material;\n            if (material instanceof MultiMaterial) {\n              for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                  materialArray.push(material.subMaterials[matIndex]);\n                }\n              }\n              for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n              }\n            } else {\n              if (materialArray.indexOf(material) < 0) {\n                materialArray.push(material);\n              }\n              for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                materialIndexArray.push(materialArray.indexOf(material));\n                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n              }\n            }\n          } else {\n            for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n              materialIndexArray.push(0);\n              indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n            }\n          }\n        }\n      }\n      const source = meshes[0];\n      const getVertexDataFromMesh = mesh => {\n        const wm = mesh.computeWorldMatrix(true);\n        const vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n        return {\n          vertexData,\n          transform: wm\n        };\n      };\n      const {\n        vertexData: sourceVertexData,\n        transform: sourceTransform\n      } = getVertexDataFromMesh(source);\n      if (isAsync) {\n        yield;\n      }\n      const meshVertexDatas = new Array(meshes.length - 1);\n      for (let i = 1; i < meshes.length; i++) {\n        meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n        if (isAsync) {\n          yield;\n        }\n      }\n      const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n      let mergeCoroutineStep = mergeCoroutine.next();\n      while (!mergeCoroutineStep.done) {\n        if (isAsync) {\n          yield;\n        }\n        mergeCoroutineStep = mergeCoroutine.next();\n      }\n      const vertexData = mergeCoroutineStep.value;\n      if (!meshSubclass) {\n        meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n      }\n      const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n      let applyToCoroutineStep = applyToCoroutine.next();\n      while (!applyToCoroutineStep.done) {\n        if (isAsync) {\n          yield;\n        }\n        applyToCoroutineStep = applyToCoroutine.next();\n      }\n      // Setting properties\n      meshSubclass.checkCollisions = source.checkCollisions;\n      meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\n      // Cleaning\n      if (disposeSource) {\n        for (index = 0; index < meshes.length; index++) {\n          meshes[index].dispose();\n        }\n      }\n      // Subdivide\n      if (subdivideWithSubMeshes || multiMultiMaterials) {\n        //-- removal of global submesh\n        meshSubclass.releaseSubMeshes();\n        index = 0;\n        let offset = 0;\n        //-- apply subdivision according to index table\n        while (index < indiceArray.length) {\n          SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n          offset += indiceArray[index];\n          index++;\n        }\n        for (const subMesh of meshSubclass.subMeshes) {\n          subMesh.refreshBoundingInfo();\n        }\n        meshSubclass.computeWorldMatrix(true);\n      }\n      if (multiMultiMaterials) {\n        const newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n        newMultiMaterial.subMaterials = materialArray;\n        for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\n          meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\n        }\n        meshSubclass.material = newMultiMaterial;\n      } else {\n        meshSubclass.material = source.material;\n      }\n      return meshSubclass;\n    }();\n  }\n  /**\n   * @internal\n   */\n  addInstance(instance) {\n    instance._indexInSourceMeshInstanceArray = this.instances.length;\n    this.instances.push(instance);\n  }\n  /**\n   * @internal\n   */\n  removeInstance(instance) {\n    // Remove from mesh\n    const index = instance._indexInSourceMeshInstanceArray;\n    if (index != -1) {\n      if (index !== this.instances.length - 1) {\n        const last = this.instances[this.instances.length - 1];\n        this.instances[index] = last;\n        last._indexInSourceMeshInstanceArray = index;\n      }\n      instance._indexInSourceMeshInstanceArray = -1;\n      this.instances.pop();\n    }\n  }\n  /** @internal */\n  _shouldConvertRHS() {\n    return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n  }\n  /** @internal */\n  _getRenderingFillMode(fillMode) {\n    var _a;\n    const scene = this.getScene();\n    if (scene.forcePointsCloud) return Material.PointFillMode;\n    if (scene.forceWireframe) return Material.WireFrameFillMode;\n    return (_a = this.overrideRenderingFillMode) !== null && _a !== void 0 ? _a : fillMode;\n  }\n}\n// Consts\n/**\n * Mesh side orientation : usually the external or front surface\n */\nMesh.FRONTSIDE = VertexData.FRONTSIDE;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nMesh.BACKSIDE = VertexData.BACKSIDE;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nMesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nMesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n/**\n * Mesh cap setting : no cap\n */\nMesh.NO_CAP = 0;\n/**\n * Mesh cap setting : one cap at the beginning of the mesh\n */\nMesh.CAP_START = 1;\n/**\n * Mesh cap setting : one cap at the end of the mesh\n */\nMesh.CAP_END = 2;\n/**\n * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n */\nMesh.CAP_ALL = 3;\n/**\n * Mesh pattern setting : no flip or rotate\n */\nMesh.NO_FLIP = 0;\n/**\n * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n */\nMesh.FLIP_TILE = 1;\n/**\n * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n */\nMesh.ROTATE_TILE = 2;\n/**\n * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n */\nMesh.FLIP_ROW = 3;\n/**\n * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n */\nMesh.ROTATE_ROW = 4;\n/**\n * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n */\nMesh.FLIP_N_ROTATE_TILE = 5;\n/**\n * Mesh pattern setting : rotate pattern and rotate\n */\nMesh.FLIP_N_ROTATE_ROW = 6;\n/**\n * Mesh tile positioning : part tiles same on left/right or top/bottom\n */\nMesh.CENTER = 0;\n/**\n * Mesh tile positioning : part tiles on left\n */\nMesh.LEFT = 1;\n/**\n * Mesh tile positioning : part tiles on right\n */\nMesh.RIGHT = 2;\n/**\n * Mesh tile positioning : part tiles on top\n */\nMesh.TOP = 3;\n/**\n * Mesh tile positioning : part tiles on bottom\n */\nMesh.BOTTOM = 4;\n/**\n * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n */\nMesh.INSTANCEDMESH_SORT_TRANSPARENT = false;\n// Statics\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GroundMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"GroundMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GoldbergMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"GoldbergMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._LinesMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"LinesMesh\");\n};\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @internal\n */\nMesh.prototype.setMaterialByID = function (id) {\n  return this.setMaterialById(id);\n};\nMesh.CreateDisc = Mesh.CreateDisc || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateBox = Mesh.CreateBox || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateSphere = Mesh.CreateSphere || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateCylinder = Mesh.CreateCylinder || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTorusKnot = Mesh.CreateTorusKnot || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTorus = Mesh.CreateTorus || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreatePlane = Mesh.CreatePlane || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateGround = Mesh.CreateGround || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTiledGround = Mesh.CreateTiledGround || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTube = Mesh.CreateTube || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreatePolyhedron = Mesh.CreatePolyhedron || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateIcoSphere = Mesh.CreateIcoSphere || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateDecal = Mesh.CreateDecal || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateCapsule = Mesh.CreateCapsule || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});"],"names":["_CreationDataStorage","_InstanceDataStorage","constructor","this","visibleInstances","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","Array","renderSelf","hardwareInstancedRendering","_ThinInstanceDataStorage","instancesCount","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","_overrideRenderingFillMode","Mesh","static","orientation","FRONTSIDE","useLODScreenCoverage","_internalMeshDataInfo","value","_sortLODLevels","computeBonesUsingShaders","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","_sourcePositions","setVerticesData","_sourceNormals","_markSubMeshesAsAttributesDirty","onBeforeRenderObservable","_onBeforeRenderObservable","onBeforeBindObservable","_onBeforeBindObservable","onAfterRenderObservable","_onAfterRenderObservable","onBetweenPassObservable","_onBetweenPassObservable","onBeforeDrawObservable","_onBeforeDrawObservable","onBeforeDraw","callback","_onBeforeDrawObserver","remove","add","hasInstances","instances","length","hasThinInstances","_a","_thinInstanceDataStorage","forcedInstanceCount","count","overrideRenderingFillMode","fillMode","source","cloneMeshMap","isUnIndexed","_unIndexed","worldMatrixInstancedBuffer","_instanceDataStorage","instancesData","previousWorldMatrixInstancedBuffer","instancesPreviousData","manualUpdateOfWorldMatrixInstancedBuffer","manualUpdate","manualUpdateOfPreviousWorldMatrixInstancedBuffer","previousManualUpdate","forceWorldMatrixInstancedBufferUpdate","forceMatrixUpdates","name","scene","arguments","undefined","parent","doNotCloneChildren","clonePhysicsImpostor","super","delayLoadState","_creationDataStorage","_geometry","_shouldGenerateFlatShading","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","getScene","_onBeforeDraw","isInstance","world","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","applyToMesh","useClonedMeshMap","uniqueId","_ranges","ranges","Object","prototype","hasOwnProperty","call","createAnimationRange","from","to","metadata","clone","_internalMetadata","setEnabled","isEnabled","setPivotMatrix","getPivotMatrix","id","material","directDescendants","getDescendants","index","child","morphTargetManager","getPhysicsEngine","physicsEngine","getPluginVersion","impostor","getImpostorForPhysicsObject","physicsImpostor","physicsBody","particleSystems","system","emitter","skeleton","refreshBoundingInfo","computeWorldMatrix","getEngine","getCaps","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","isReady","onMeshReadyObservable","notifyObservers","_checkReadinessObserver","_scene","onClonedObservable","instantiateHierarchy","newParent","options","onNewNodeCreated","instance","getTotalVertices","doNotInstantiate","createInstance","position","scaling","rotationQuaternion","rotation","getChildTransformNodes","getClassName","sourceMesh","newSourcedMesh","_isMesh","toString","fullDetails","ret","_waitingParentId","animations","i","ib","getIndices","vb","getVerticesData","_unBindEffect","hasLODLevels","getLODLevels","sortingOrderFactor","sort","a","b","distanceOrScreenCoverage","addLODLevel","mesh","_masterMesh","level","push","getLODLevelAtDistance","distance","internalDataInfo","removeLODLevel","splice","getLOD","camera","boundingSphere","bSphere","getBoundingInfo","distanceToCamera","mode","minZ","centerWorld","subtract","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","Math","PI","onLODLevelSelection","_checkDelayState","_preActivate","_updateSubMeshesBoundingInfo","worldMatrixFromCache","geometry","kind","copyWhenShared","forceCopy","bypassInstanceData","_b","data","_userInstancedBuffersStorage","vertexBuffers","getFloatData","meshes","getVertexBuffer","isVerticesDataPresent","_delayInfo","indexOf","isVertexBufferUpdatable","buffer","isUpdatable","getVerticesDataKinds","result","forEach","kinds","getTotalIndices","isBlocked","completeCheck","forceInstanceSupport","_c","_d","_e","_f","subMeshes","engine","mat","defaultMaterial","_storeEffectOnSubMeshes","subMesh","getMaterial","isReadyForSubMesh","currentRenderPassId","light","lightSources","generators","getShadowGenerators","iterator","values","key","next","done","generator","getShadowMap","renderList","renderPassId","needAlphaBlendingForMesh","lod","areNormalsFrozen","freezeNormals","unfreezeNormals","overridenInstanceCount","sceneRenderId","getRenderId","_preActivateForIntermediateRendering","renderId","intermediateDefaultRenderId","_registerInstanceForRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","_afterComputeWorldMatrix","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","_postActivate","edgesShareWithInstances","edgesRenderer","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","applySkeleton","applyMorph","hasBoundingInfo","isLocked","bias","boundingBias","_refreshBoundingInfo","_getPositionData","_createGlobalSubMesh","force","totalVertices","totalIndices","needToRecreate","submesh","indexStart","indexCount","verticesStart","verticesCount","releaseSubMeshes","subdivide","subdivisionSize","offset","synchronizeInstances","updatable","stride","vertexData","set","removeVerticesData","markVerticesDataAsUpdatable","setVerticesBuffer","disposeExistingBuffer","updateVerticesData","updateExtends","makeItUnique","makeGeometryUnique","updateMeshPositions","positionFunction","computeNormals","positions","indices","normals","oldGeometry","copy","releaseForMesh","setIndices","updateIndices","gpuMemoryOnly","toLeftHanded","_bind","effect","allowInstancedRendering","indexToBind","isUsingTextureForTargets","_getRenderingFillMode","_getLinesIndexBuffer","getIndexBuffer","vertexArrayObjects","_draw","getVertexBuffers","drawArraysType","drawElementsType","_linesIndexCount","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_getInstancesRenderList","subMeshId","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","_onlyForInstancesIntermediate","_onlyForInstances","isVisible","currentRenderId","_renderWithInstances","batch","_id","visibleInstanceCount","instanceStorage","currentInstancesBufferSize","instancesBuffer","instancesPreviousBuffer","bufferSize","Float32Array","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","copyToArray","copyFrom","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceIndex","instanceMesh","_distanceToCamera","m1","m2","matrix","_previousWorldMatrix","dispose","strides","sizes","vertexArrayObject","createVertexBuffer","_invalidateInstanceVertexArrayObject","updateDirectly","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","unbindInstanceAttributes","_renderWithThinInstances","previousMatrixData","_thinInstanceCreateMatrixBuffer","_processRendering","renderingMesh","instanceCount","visibleInstancesForSubMesh","_rebuild","_freeze","_unFreeze","render","enableAlphaMode","effectiveMeshReplacement","_isActiveIntermediate","_isActive","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","maxZ","updateTransformMatrix","getMesh","_actAsRegularMesh","instanceDataStorage","_wasPreviouslyReady","getEffect","drawWrapper","setAlphaMode","alphaMode","_drawWrapper","_getDrawWrapper","step","_beforeRenderingMeshStage","action","effectiveMesh","sideOrientation","backFaceCulling","mainDeterminant","_getWorldMatrixDeterminant","reverse","_preBind","forceDepthWrite","setDepthWrite","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","unbind","_afterRenderingMeshStage","performancePriority","cleanMatrixWeights","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","matricesWeights","numWeights","t","recip","matricesWeightsExtra","validateSkinning","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","lastWeight","usedWeights","d","tolerance","abs","numBones","bones","matricesIndices","matricesIndicesExtra","numBadBoneIndices","load","_queueLoad","addPendingData","getBinaryData","delayLoadingFile","ArrayBuffer","_delayLoadingFunction","JSON","parse","_syncSubMeshes","removePendingData","offlineProvider","isInFrustum","frustumPlanes","setMaterialById","materials","multiMaterials","getAnimatables","results","bakeTransformIntoVertices","transform","submeshes","_resetPointsArrayCache","temp","toArray","normalize","determinant","flipFaces","bakeCurrentTransformIntoVertices","bakeIndependentlyOfChildren","resetLocalMatrix","_positions","_generatePointsArray","doNotRecurse","disposeMaterialAndTextures","clear","abstractMesh","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","applyDisplacementMap","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","forceUpdate","img","heightMapWidth","width","heightMapHeight","height","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","uvs","normal","uv","pos","x","y","gradient","scaleInPlace","convertToFlatShadedMesh","vbs","newdata","kindIndex","updatableNormals","vertexBuffer","getData","previousSubmeshes","slice","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p3","p1p2","p3p2","localIndex","z","submeshIndex","previousOne","materialIndex","convertToUnIndexedMesh","flipNormals","vertex_data","increaseVertices","numberPerEdge","currentIndices","isArray","segments","tempIndices","deltaPosition","deltaNormal","deltaUV","side","len","uvPtr","normalsPtr","positionPtr","j","k","idx","forceSharedVertices","currentUVs","currentPositions","currentColors","colors","currentMatrixIndices","currentMatrixWeights","currentMatrixIndicesExtra","currentMatrixWeightsExtra","matrixIndices","matrixWeights","matrixIndicesExtra","matrixWeightsExtra","pstring","indexPtr","uniquePositions","ptr","facet","physicObject","jsonObject","_instancedMeshFactory","optimizeIndices","successCallback","vectorPositions","dupes","iteration","realPos","testedPosition","againstPosition","equals","originalSubMeshes","serialize","serializationObject","type","tags","asArray","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","infiniteDistance","pickable","isPickable","receiveShadows","billboardMode","visibility","checkCollisions","isBlocker","_serializeAsParent","geometryUniqueId","geometryId","subIndex","doNotSerialize","materialUniqueId","materialId","morphTargetManagerId","skeletonId","numBoneInfluencers","_getComponent","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","actionManager","actions","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","_syncGeometryWithMorphTargetManager","_morphTargetManager","vertexCount","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","tangents","getTangents","getUVs","parsedMesh","rootUrl","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","_waitingParsedUniqueId","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","parentId","parentInstanceIndex","_waitingParentInstanceIndex","buildBoundingInfo","boundingBoxMinimum","boundingBoxMaximum","_binaryInfo","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","_waitingMaterialId","getMorphTargetManagerById","getLastSkeletonById","animationIndex","parsedAnimation","internalClass","Parse","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","_PhysicsImpostorParser","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","thinInstanceSetBuffer","setPositionsForCPUSkinning","setNormalsForCPUSkinning","_softwareSkinningFrameId","getFrameId","hasNormals","positionsData","normalsData","matricesIndicesData","matricesWeightsData","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","inf","matWeightIdx","weight","floor","addToSelf","reset","minVector","maxVector","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","min","max","meshesOrMinMaxVector","minMaxVector","MinMax","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","isAsync","filter","Boolean","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","isAnInstance","matIndex","subMaterials","getVertexDataFromMesh","wm","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","_mergeCoroutine","mergeCoroutineStep","applyToCoroutine","_applyToCoroutine","applyToCoroutineStep","newMultiMaterial","addInstance","_indexInSourceMeshInstanceArray","removeInstance","last","pop","_shouldConvertRHS","forcePointsCloud","forceWireframe","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","CreateDisc","Error","CreateBox","CreateSphere","CreateCylinder","CreateTorusKnot","CreateTorus","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreateTube","CreatePolyhedron","CreateIcoSphere","CreateDecal","CreateCapsule","ExtendToGoldberg"],"sourceRoot":""}