{"version":3,"file":"702596cc-60b472c83e199db7d100.js","mappings":"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","sources":["webpack://@react-babylonjs/docs/../../node_modules/@babylonjs/core/scene.js"],"sourcesContent":["import _defineProperty from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/home/runner/work/react-babylonjs/react-babylonjs/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\nexport var ScenePerformancePriority;\n(function (ScenePerformancePriority) {\n  /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n  ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n  /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n  ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n  /** Performance will be top priority */\n  ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\n */\nexport var Scene = /*#__PURE__*/function (_AbstractScene) {\n  _inherits(Scene, _AbstractScene);\n  var _super = _createSuper(Scene);\n  /**\n   * Creates a new Scene\n   * @param engine defines the engine to use to render this scene\n   * @param options defines the scene options\n   */\n  function Scene(engine, options) {\n    var _this;\n    _classCallCheck(this, Scene);\n    _this = _super.call(this);\n    // Members\n    /** @internal */\n    _this._inputManager = new InputManager(_assertThisInitialized(_this));\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n    _this.cameraToUseForPointers = null;\n    /** @internal */\n    _this._isScene = true;\n    /** @internal */\n    _this._blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n    _this.autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n    _this.autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n    _this.ambientColor = new Color3(0, 0, 0);\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    _this.environmentIntensity = 1;\n    _this._performancePriority = ScenePerformancePriority.BackwardCompatible;\n    /**\n     * Observable triggered when the performance priority is changed\n     */\n    _this.onScenePerformancePriorityChangedObservable = new Observable();\n    _this._forceWireframe = false;\n    _this._skipFrustumClipping = false;\n    _this._forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n    _this.animationsEnabled = true;\n    _this._animationPropertiesOverride = null;\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n    _this.useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n    _this.constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n    _this.hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n    _this.defaultCursor = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n    _this.doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n    _this.preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n    _this.preventDefaultOnPointerUp = true;\n    // Metadata\n    /**\n     * Gets or sets user defined metadata\n     */\n    _this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    _this.reservedDataStore = null;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n    _this.disableOfflineSupportExceptionRules = new Array();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n    _this.onBeforeRenderObservable = new Observable();\n    _this._onBeforeRenderObserver = null;\n    /**\n     * An event triggered after rendering the scene\n     */\n    _this.onAfterRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n     */\n    _this.onAfterRenderCameraObservable = new Observable();\n    _this._onAfterRenderObserver = null;\n    /**\n     * An event triggered before animating the scene\n     */\n    _this.onBeforeAnimationsObservable = new Observable();\n    /**\n     * An event triggered after animations processing\n     */\n    _this.onAfterAnimationsObservable = new Observable();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n    _this.onBeforeDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n    _this.onAfterDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered when the scene is ready\n     */\n    _this.onReadyObservable = new Observable();\n    /**\n     * An event triggered before rendering a camera\n     */\n    _this.onBeforeCameraRenderObservable = new Observable();\n    _this._onBeforeCameraRenderObserver = null;\n    /**\n     * An event triggered after rendering a camera\n     * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n     */\n    _this.onAfterCameraRenderObservable = new Observable();\n    _this._onAfterCameraRenderObserver = null;\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n    _this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    _this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    _this.onAfterParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n    _this.onDataLoadedObservable = new Observable();\n    /**\n     * An event triggered when a camera is created\n     */\n    _this.onNewCameraAddedObservable = new Observable();\n    /**\n     * An event triggered when a camera is removed\n     */\n    _this.onCameraRemovedObservable = new Observable();\n    /**\n     * An event triggered when a light is created\n     */\n    _this.onNewLightAddedObservable = new Observable();\n    /**\n     * An event triggered when a light is removed\n     */\n    _this.onLightRemovedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is created\n     */\n    _this.onNewGeometryAddedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is removed\n     */\n    _this.onGeometryRemovedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is created\n     */\n    _this.onNewTransformNodeAddedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is removed\n     */\n    _this.onTransformNodeRemovedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is created\n     */\n    _this.onNewMeshAddedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is removed\n     */\n    _this.onMeshRemovedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is created\n     */\n    _this.onNewSkeletonAddedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n    _this.onSkeletonRemovedObservable = new Observable();\n    /**\n     * An event triggered when a material is created\n     */\n    _this.onNewMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is created\n     */\n    _this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a material is removed\n     */\n    _this.onMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is removed\n     */\n    _this.onMultiMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a texture is created\n     */\n    _this.onNewTextureAddedObservable = new Observable();\n    /**\n     * An event triggered when a texture is removed\n     */\n    _this.onTextureRemovedObservable = new Observable();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n    _this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n    _this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n    _this.onBeforeStepObservable = new Observable();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n    _this.onAfterStepObservable = new Observable();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n    _this.onActiveCameraChanged = new Observable();\n    /**\n     * An event triggered when the activeCameras property is updated\n     */\n    _this.onActiveCamerasChanged = new Observable();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    _this.onBeforeRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    _this.onAfterRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n    _this.onMeshImportedObservable = new Observable();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n    _this.onAnimationFileImportedObservable = new Observable();\n    // Animations\n    /** @internal */\n    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n     */\n    _this.skipPointerMovePicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n     */\n    _this.skipPointerDownPicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n     */\n    _this.skipPointerUpPicking = false;\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n    _this.onPrePointerObservable = new Observable();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n    _this.onPointerObservable = new Observable();\n    // Keyboard\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n    _this.onPreKeyboardObservable = new Observable();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n    _this.onKeyboardObservable = new Observable();\n    // Coordinates system\n    _this._useRightHandedSystem = false;\n    // Deterministic lockstep\n    _this._timeAccumulator = 0;\n    _this._currentStepId = 0;\n    _this._currentInternalStep = 0;\n    // Fog\n    _this._fogEnabled = true;\n    _this._fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n    _this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0.1)\n     */\n    _this.fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0)\n     */\n    _this.fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 1000)\n     */\n    _this.fogEnd = 1000.0;\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n    _this.needsPreviousWorldMatrices = false;\n    // Lights\n    _this._shadowsEnabled = true;\n    _this._lightsEnabled = true;\n    _this._unObserveActiveCameras = null;\n    // Textures\n    _this._texturesEnabled = true;\n    // Physics\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n    _this.physicsEnabled = true;\n    // Particles\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n    _this.particlesEnabled = true;\n    // Sprites\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n    _this.spritesEnabled = true;\n    // Skeletons\n    _this._skeletonsEnabled = true;\n    // Lens flares\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n    _this.lensFlaresEnabled = true;\n    // Collisions\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    _this.collisionsEnabled = true;\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    _this.gravity = new Vector3(0, -9.807, 0);\n    // Postprocesses\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n    _this.postProcessesEnabled = true;\n    // Customs render targets\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n    _this.renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n    _this.dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n    _this.customRenderTargets = new Array();\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n    _this.importedMeshesFiles = new Array();\n    // Probes\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n    _this.probesEnabled = true;\n    _this._meshesForIntersections = new SmartArrayNoDuplicate(256);\n    // Procedural textures\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n    _this.proceduralTexturesEnabled = true;\n    // Performance counters\n    _this._totalVertices = new PerfCounter();\n    /** @internal */\n    _this._activeIndices = new PerfCounter();\n    /** @internal */\n    _this._activeParticles = new PerfCounter();\n    /** @internal */\n    _this._activeBones = new PerfCounter();\n    /** @internal */\n    _this._animationTime = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n    _this.animationTimeScale = 1;\n    _this._renderId = 0;\n    _this._frameId = 0;\n    _this._executeWhenReadyTimeoutId = null;\n    _this._intermediateRendering = false;\n    _this._defaultFrameBufferCleared = false;\n    _this._viewUpdateFlag = -1;\n    _this._projectionUpdateFlag = -1;\n    /** @internal */\n    _this._toBeDisposed = new Array(256);\n    _this._activeRequests = new Array();\n    /** @internal */\n    _this._pendingData = new Array();\n    _this._isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n    _this.dispatchAllSubMeshesOfActiveMeshes = false;\n    _this._activeMeshes = new SmartArray(256);\n    _this._processedMaterials = new SmartArray(256);\n    _this._renderTargets = new SmartArrayNoDuplicate(256);\n    _this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n    /** @internal */\n    _this._activeParticleSystems = new SmartArray(256);\n    _this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @internal */\n    _this._activeAnimatables = new Array();\n    _this._transformMatrix = Matrix.Zero();\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n    _this.requireLightSorting = false;\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    _this._components = [];\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    _this._serializableComponents = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n    _this._transientComponents = [];\n    /**\n     * @internal\n     * Defines the actions happening before camera updates.\n     */\n    _this._beforeCameraUpdateStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    _this._beforeClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    _this._beforeRenderTargetClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions when collecting render targets for the frame.\n     */\n    _this._gatherRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening for one camera in the frame.\n     */\n    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per mesh ready checks.\n     */\n    _this._isReadyForMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n    _this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n    _this._evaluateSubMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the active mesh stage.\n     */\n    _this._preActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per camera render target step.\n     */\n    _this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before the active camera is drawing.\n     */\n    _this._beforeCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a render target is drawing.\n     */\n    _this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n    _this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a mesh is drawing.\n     */\n    _this._beforeRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n    _this._afterRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n    _this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n    _this._afterCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the post processing\n     */\n    _this._afterCameraPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a render target has been drawn.\n     */\n    _this._afterRenderTargetDrawStage = Stage.Create();\n    /**\n     * Defines the actions happening just after the post processing on a render target\n     */\n    _this._afterRenderTargetPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n    _this._afterRenderStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer move event happens.\n     */\n    _this._pointerMoveStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer down event happens.\n     */\n    _this._pointerDownStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer up event happens.\n     */\n    _this._pointerUpStage = Stage.Create();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n    _this._geometriesByUniqueId = null;\n    _this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @internal */\n    _this._activeMeshesFrozen = false;\n    /** @internal */\n    _this._activeMeshesFrozenButKeepClipping = false;\n    _this._skipEvaluateActiveMeshesCompletely = false;\n    /** @internal */\n    _this._allowPostProcessClearColor = true;\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n    _this.getDeterministicFrameTime = function () {\n      return _this._engine.getTimeStep();\n    };\n    /** @internal */\n    _this._registeredActions = 0;\n    _this._blockMaterialDirtyMechanism = false;\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n    _this._perfCollector = null;\n    _this.activeCameras = new Array();\n    var fullOptions = _objectSpread({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n    _this._engine = engine || EngineStore.LastCreatedEngine;\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = _assertThisInitialized(_this);\n      _this._engine.scenes.push(_assertThisInitialized(_this));\n    } else {\n      _this._engine._virtualScenes.push(_assertThisInitialized(_this));\n    }\n    _this._uid = null;\n    _this._renderingManager = new RenderingManager(_assertThisInitialized(_this));\n    if (PostProcessManager) {\n      _this.postProcessManager = new PostProcessManager(_assertThisInitialized(_this));\n    }\n    if (IsWindowObjectExist()) {\n      _this.attachControl();\n    }\n    // Uniform Buffer\n    _this._createUbo();\n    // Default Image processing definition\n    if (ImageProcessingConfiguration) {\n      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n    _this.setDefaultCandidateProviders();\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      _this._geometriesByUniqueId = {};\n    }\n    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n    if (!options || !options.virtual) {\n      _this._engine.onNewSceneAddedObservable.notifyObservers(_assertThisInitialized(_this));\n    }\n    return _this;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"Scene\" string\n   */\n  _createClass(Scene, [{\n    key: \"environmentTexture\",\n    get:\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    function get() {\n      return this._environmentTexture;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */,\n    set: function set(value) {\n      if (this._environmentTexture === value) {\n        return;\n      }\n      this._environmentTexture = value;\n      this.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n  }, {\n    key: \"imageProcessingConfiguration\",\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    }\n    /**\n     * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n     */\n  }, {\n    key: \"performancePriority\",\n    get: function get() {\n      return this._performancePriority;\n    },\n    set: function set(value) {\n      if (value === this._performancePriority) {\n        return;\n      }\n      this._performancePriority = value;\n      switch (value) {\n        case ScenePerformancePriority.BackwardCompatible:\n          this.skipFrustumClipping = false;\n          this._renderingManager.maintainStateBetweenFrames = false;\n          this.skipPointerMovePicking = false;\n          this.autoClear = true;\n          break;\n        case ScenePerformancePriority.Intermediate:\n          this.skipFrustumClipping = false;\n          this._renderingManager.maintainStateBetweenFrames = false;\n          this.skipPointerMovePicking = true;\n          this.autoClear = false;\n          break;\n        case ScenePerformancePriority.Aggressive:\n          this.skipFrustumClipping = true;\n          this._renderingManager.maintainStateBetweenFrames = true;\n          this.skipPointerMovePicking = true;\n          this.autoClear = false;\n          break;\n      }\n      this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n  }, {\n    key: \"forceWireframe\",\n    get: function get() {\n      return this._forceWireframe;\n    }\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */,\n    set: function set(value) {\n      if (this._forceWireframe === value) {\n        return;\n      }\n      this._forceWireframe = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"skipFrustumClipping\",\n    get: function get() {\n      return this._skipFrustumClipping;\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */,\n    set: function set(value) {\n      if (this._skipFrustumClipping === value) {\n        return;\n      }\n      this._skipFrustumClipping = value;\n    }\n  }, {\n    key: \"forcePointsCloud\",\n    get: function get() {\n      return this._forcePointsCloud;\n    }\n    /**\n     * Gets or sets the animation properties override\n     */,\n    set: function set(value) {\n      if (this._forcePointsCloud === value) {\n        return;\n      }\n      this._forcePointsCloud = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"animationPropertiesOverride\",\n    get: function get() {\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    }\n    /** Sets a function to be executed when this scene is disposed. */\n  }, {\n    key: \"onDispose\",\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /** Sets a function to be executed before rendering this scene */\n  }, {\n    key: \"beforeRender\",\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n      if (callback) {\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n      }\n    }\n    /** Sets a function to be executed after rendering this scene */\n  }, {\n    key: \"afterRender\",\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n      if (callback) {\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n      }\n    }\n    /** Sets a function to be executed before rendering a camera*/\n  }, {\n    key: \"beforeCameraRender\",\n    set: function set(callback) {\n      if (this._onBeforeCameraRenderObserver) {\n        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n      }\n      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    }\n    /** Sets a function to be executed after rendering a camera*/\n  }, {\n    key: \"afterCameraRender\",\n    set: function set(callback) {\n      if (this._onAfterCameraRenderObserver) {\n        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n      }\n      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    }\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n  }, {\n    key: \"unTranslatedPointer\",\n    get: function get() {\n      return this._inputManager.unTranslatedPointer;\n    }\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n  }, {\n    key: \"bindEyePosition\",\n    value:\n    /**\n     * Bind the current view position to an effect.\n     * @param effect The effect to be bound\n     * @param variableName name of the shader variable that will hold the eye position\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n     * @returns the computed eye position\n     */\n    function bindEyePosition(effect) {\n      var variableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vEyePosition\";\n      var isVector3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _a;\n      var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;\n      var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n      TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n      if (effect) {\n        if (isVector3) {\n          effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n        } else {\n          effect.setVector4(variableName, TmpVectors.Vector4[0]);\n        }\n      }\n      return TmpVectors.Vector4[0];\n    }\n    /**\n     * Update the scene ubo before it can be used in rendering processing\n     * @returns the scene UniformBuffer\n     */\n  }, {\n    key: \"finalizeSceneUbo\",\n    value: function finalizeSceneUbo() {\n      var ubo = this.getSceneUniformBuffer();\n      var eyePosition = this.bindEyePosition(null);\n      ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n      ubo.update();\n      return ubo;\n    }\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n  }, {\n    key: \"useRightHandedSystem\",\n    get: function get() {\n      return this._useRightHandedSystem;\n    }\n    /**\n     * Sets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @param newStepId defines the step Id\n     */,\n    set: function set(value) {\n      if (this._useRightHandedSystem === value) {\n        return;\n      }\n      this._useRightHandedSystem = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"setStepId\",\n    value: function setStepId(newStepId) {\n      this._currentStepId = newStepId;\n    }\n    /**\n     * Gets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the step Id\n     */\n  }, {\n    key: \"getStepId\",\n    value: function getStepId() {\n      return this._currentStepId;\n    }\n    /**\n     * Gets the internal step used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the internal step\n     */\n  }, {\n    key: \"getInternalStep\",\n    value: function getInternalStep() {\n      return this._currentInternalStep;\n    }\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is true)\n     */\n  }, {\n    key: \"fogEnabled\",\n    get: function get() {\n      return this._fogEnabled;\n    }\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */,\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n      this._fogEnabled = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"fogMode\",\n    get: function get() {\n      return this._fogMode;\n    }\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */,\n    set: function set(value) {\n      if (this._fogMode === value) {\n        return;\n      }\n      this._fogMode = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"prePass\",\n    get: function get() {\n      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n  }, {\n    key: \"shadowsEnabled\",\n    get: function get() {\n      return this._shadowsEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */,\n    set: function set(value) {\n      if (this._shadowsEnabled === value) {\n        return;\n      }\n      this._shadowsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    }\n  }, {\n    key: \"lightsEnabled\",\n    get: function get() {\n      return this._lightsEnabled;\n    }\n    /** All of the active cameras added to this scene. */,\n    set: function set(value) {\n      if (this._lightsEnabled === value) {\n        return;\n      }\n      this._lightsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    }\n  }, {\n    key: \"activeCameras\",\n    get: function get() {\n      return this._activeCameras;\n    },\n    set: function set(cameras) {\n      var _this2 = this;\n      if (this._unObserveActiveCameras) {\n        this._unObserveActiveCameras();\n        this._unObserveActiveCameras = null;\n      }\n      if (cameras) {\n        this._unObserveActiveCameras = _ObserveArray(cameras, function () {\n          _this2.onActiveCamerasChanged.notifyObservers(_this2);\n        });\n      }\n      this._activeCameras = cameras;\n    }\n    /** Gets or sets the current active camera */\n  }, {\n    key: \"activeCamera\",\n    get: function get() {\n      return this._activeCamera;\n    },\n    set: function set(value) {\n      if (value === this._activeCamera) {\n        return;\n      }\n      this._activeCamera = value;\n      this.onActiveCameraChanged.notifyObservers(this);\n    }\n    /** The default material used on meshes when no material is affected */\n  }, {\n    key: \"defaultMaterial\",\n    get: function get() {\n      if (!this._defaultMaterial) {\n        this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n      }\n      return this._defaultMaterial;\n    }\n    /** The default material used on meshes when no material is affected */,\n    set: function set(value) {\n      this._defaultMaterial = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n  }, {\n    key: \"texturesEnabled\",\n    get: function get() {\n      return this._texturesEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */,\n    set: function set(value) {\n      if (this._texturesEnabled === value) {\n        return;\n      }\n      this._texturesEnabled = value;\n      this.markAllMaterialsAsDirty(1);\n    }\n  }, {\n    key: \"skeletonsEnabled\",\n    get: function get() {\n      return this._skeletonsEnabled;\n    }\n    /** @internal */,\n    set: function set(value) {\n      if (this._skeletonsEnabled === value) {\n        return;\n      }\n      this._skeletonsEnabled = value;\n      this.markAllMaterialsAsDirty(8);\n    }\n  }, {\n    key: \"collisionCoordinator\",\n    get: function get() {\n      if (!this._collisionCoordinator) {\n        this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n        this._collisionCoordinator.init(this);\n      }\n      return this._collisionCoordinator;\n    }\n    /**\n     * Gets the scene's rendering manager\n     */\n  }, {\n    key: \"renderingManager\",\n    get: function get() {\n      return this._renderingManager;\n    }\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n  }, {\n    key: \"frustumPlanes\",\n    get: function get() {\n      return this._frustumPlanes;\n    }\n    /**\n     * Registers the transient components if needed.\n     */\n  }, {\n    key: \"_registerTransientComponents\",\n    value: function _registerTransientComponents() {\n      // Register components that have been associated lately to the scene.\n      if (this._transientComponents.length > 0) {\n        var _iterator = _createForOfIteratorHelper(this._transientComponents),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var component = _step.value;\n            component.register();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this._transientComponents.length = 0;\n      }\n    }\n    /**\n     * @internal\n     * Add a component to the scene.\n     * Note that the ccomponent could be registered on th next frame if this is called after\n     * the register component stage.\n     * @param component Defines the component to add to the scene\n     */\n  }, {\n    key: \"_addComponent\",\n    value: function _addComponent(component) {\n      this._components.push(component);\n      this._transientComponents.push(component);\n      var serializableComponent = component;\n      if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n        this._serializableComponents.push(serializableComponent);\n      }\n    }\n    /**\n     * @internal\n     * Gets a component from the scene.\n     * @param name defines the name of the component to retrieve\n     * @returns the component or null if not present\n     */\n  }, {\n    key: \"_getComponent\",\n    value: function _getComponent(name) {\n      var _iterator2 = _createForOfIteratorHelper(this._components),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n          if (component.name === name) {\n            return component;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return null;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return \"Scene\";\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_getDefaultMeshCandidates\",\n    value: function _getDefaultMeshCandidates() {\n      this._defaultMeshCandidates.data = this.meshes;\n      this._defaultMeshCandidates.length = this.meshes.length;\n      return this._defaultMeshCandidates;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_getDefaultSubMeshCandidates\",\n    value: function _getDefaultSubMeshCandidates(mesh) {\n      this._defaultSubMeshCandidates.data = mesh.subMeshes;\n      this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n      return this._defaultSubMeshCandidates;\n    }\n    /**\n     * Sets the default candidate providers for the scene.\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n     * and getCollidingSubMeshCandidates to their default function\n     */\n  }, {\n    key: \"setDefaultCandidateProviders\",\n    value: function setDefaultCandidateProviders() {\n      this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n      this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n      this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n      this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    }\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n  }, {\n    key: \"meshUnderPointer\",\n    get: function get() {\n      return this._inputManager.meshUnderPointer;\n    }\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n  }, {\n    key: \"pointerX\",\n    get: function get() {\n      return this._inputManager.pointerX;\n    },\n    set: function set(value) {\n      this._inputManager.pointerX = value;\n    }\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n  }, {\n    key: \"pointerY\",\n    get: function get() {\n      return this._inputManager.pointerY;\n    },\n    set: function set(value) {\n      this._inputManager.pointerY = value;\n    }\n    /**\n     * Gets the cached material (ie. the latest rendered one)\n     * @returns the cached material\n     */\n  }, {\n    key: \"getCachedMaterial\",\n    value: function getCachedMaterial() {\n      return this._cachedMaterial;\n    }\n    /**\n     * Gets the cached effect (ie. the latest rendered one)\n     * @returns the cached effect\n     */\n  }, {\n    key: \"getCachedEffect\",\n    value: function getCachedEffect() {\n      return this._cachedEffect;\n    }\n    /**\n     * Gets the cached visibility state (ie. the latest rendered one)\n     * @returns the cached visibility state\n     */\n  }, {\n    key: \"getCachedVisibility\",\n    value: function getCachedVisibility() {\n      return this._cachedVisibility;\n    }\n    /**\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\n     * @param material defines the current material\n     * @param effect defines the current effect\n     * @param visibility defines the current visibility state\n     * @returns true if one parameter is not cached\n     */\n  }, {\n    key: \"isCachedMaterialInvalid\",\n    value: function isCachedMaterialInvalid(material, effect) {\n      var visibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n    }\n    /**\n     * Gets the engine associated with the scene\n     * @returns an Engine\n     */\n  }, {\n    key: \"getEngine\",\n    value: function getEngine() {\n      return this._engine;\n    }\n    /**\n     * Gets the total number of vertices rendered per frame\n     * @returns the total number of vertices rendered per frame\n     */\n  }, {\n    key: \"getTotalVertices\",\n    value: function getTotalVertices() {\n      return this._totalVertices.current;\n    }\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n  }, {\n    key: \"totalVerticesPerfCounter\",\n    get: function get() {\n      return this._totalVertices;\n    }\n    /**\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n     * @returns the total number of active indices rendered per frame\n     */\n  }, {\n    key: \"getActiveIndices\",\n    value: function getActiveIndices() {\n      return this._activeIndices.current;\n    }\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n  }, {\n    key: \"totalActiveIndicesPerfCounter\",\n    get: function get() {\n      return this._activeIndices;\n    }\n    /**\n     * Gets the total number of active particles rendered per frame\n     * @returns the total number of active particles rendered per frame\n     */\n  }, {\n    key: \"getActiveParticles\",\n    value: function getActiveParticles() {\n      return this._activeParticles.current;\n    }\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n  }, {\n    key: \"activeParticlesPerfCounter\",\n    get: function get() {\n      return this._activeParticles;\n    }\n    /**\n     * Gets the total number of active bones rendered per frame\n     * @returns the total number of active bones rendered per frame\n     */\n  }, {\n    key: \"getActiveBones\",\n    value: function getActiveBones() {\n      return this._activeBones.current;\n    }\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n  }, {\n    key: \"activeBonesPerfCounter\",\n    get: function get() {\n      return this._activeBones;\n    }\n    /**\n     * Gets the array of active meshes\n     * @returns an array of AbstractMesh\n     */\n  }, {\n    key: \"getActiveMeshes\",\n    value: function getActiveMeshes() {\n      return this._activeMeshes;\n    }\n    /**\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n     * @returns a number\n     */\n  }, {\n    key: \"getAnimationRatio\",\n    value: function getAnimationRatio() {\n      return this._animationRatio !== undefined ? this._animationRatio : 1;\n    }\n    /**\n     * Gets an unique Id for the current render phase\n     * @returns a number\n     */\n  }, {\n    key: \"getRenderId\",\n    value: function getRenderId() {\n      return this._renderId;\n    }\n    /**\n     * Gets an unique Id for the current frame\n     * @returns a number\n     */\n  }, {\n    key: \"getFrameId\",\n    value: function getFrameId() {\n      return this._frameId;\n    }\n    /** Call this function if you want to manually increment the render Id*/\n  }, {\n    key: \"incrementRenderId\",\n    value: function incrementRenderId() {\n      this._renderId++;\n    }\n  }, {\n    key: \"_createUbo\",\n    value: function _createUbo() {\n      this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n    }\n    /**\n     * Use this method to simulate a pointer move on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n  }, {\n    key: \"simulatePointerMove\",\n    value: function simulatePointerMove(pickResult, pointerEventInit) {\n      this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n      return this;\n    }\n    /**\n     * Use this method to simulate a pointer down on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n  }, {\n    key: \"simulatePointerDown\",\n    value: function simulatePointerDown(pickResult, pointerEventInit) {\n      this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n      return this;\n    }\n    /**\n     * Use this method to simulate a pointer up on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n     * @returns the current scene\n     */\n  }, {\n    key: \"simulatePointerUp\",\n    value: function simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n      this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n      return this;\n    }\n    /**\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n     * @returns true if the pointer was captured\n     */\n  }, {\n    key: \"isPointerCaptured\",\n    value: function isPointerCaptured() {\n      var pointerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._inputManager.isPointerCaptured(pointerId);\n    }\n    /**\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n     * @param attachUp defines if you want to attach events to pointerup\n     * @param attachDown defines if you want to attach events to pointerdown\n     * @param attachMove defines if you want to attach events to pointermove\n     */\n  }, {\n    key: \"attachControl\",\n    value: function attachControl() {\n      var attachUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var attachDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var attachMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      this._inputManager.attachControl(attachUp, attachDown, attachMove);\n    }\n    /** Detaches all event handlers*/\n  }, {\n    key: \"detachControl\",\n    value: function detachControl() {\n      this._inputManager.detachControl();\n    }\n    /**\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n     * Delay loaded resources are not taking in account\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n     * @returns true if all required resources are ready\n     */\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this._isDisposed) {\n        return false;\n      }\n      var index;\n      var engine = this.getEngine();\n      var isReady = true;\n      // Pending data\n      if (this._pendingData.length > 0) {\n        isReady = false;\n      }\n      // Meshes\n      if (checkRenderTargets) {\n        this._processedMaterials.reset();\n        this._materialsRenderTargets.reset();\n      }\n      for (index = 0; index < this.meshes.length; index++) {\n        var mesh = this.meshes[index];\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n          continue;\n        }\n        // Do not stop at the first encountered \"unready\" object as we want to ensure\n        // all materials are starting off their compilation in parallel.\n        if (!mesh.isReady(true)) {\n          isReady = false;\n          continue;\n        }\n        var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0;\n        // Is Ready For Mesh\n        var _iterator3 = _createForOfIteratorHelper(this._isReadyForMeshStage),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var step = _step3.value;\n            if (!step.action(mesh, hardwareInstancedRendering)) {\n              isReady = false;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (!checkRenderTargets) {\n          continue;\n        }\n        var mat = mesh.material || this.defaultMaterial;\n        if (mat) {\n          if (mat._storeEffectOnSubMeshes) {\n            var _iterator4 = _createForOfIteratorHelper(mesh.subMeshes),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var subMesh = _step4.value;\n                var material = subMesh.getMaterial();\n                if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                  if (this._processedMaterials.indexOf(material) === -1) {\n                    this._processedMaterials.push(material);\n                    this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n              if (this._processedMaterials.indexOf(mat) === -1) {\n                this._processedMaterials.push(mat);\n                this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n              }\n            }\n          }\n        }\n      }\n      if (!isReady) {\n        return false;\n      }\n      // Effects\n      if (!engine.areAllEffectsReady()) {\n        return false;\n      }\n      // Render targets\n      if (checkRenderTargets) {\n        for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n          var rtt = this._materialsRenderTargets.data[index];\n          if (!rtt.isReadyForRendering()) {\n            return false;\n          }\n        }\n      }\n      // Geometries\n      for (index = 0; index < this.geometries.length; index++) {\n        var geometry = this.geometries[index];\n        if (geometry.delayLoadState === 2) {\n          return false;\n        }\n      }\n      // Post-processes\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        var _iterator5 = _createForOfIteratorHelper(this.activeCameras),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var camera = _step5.value;\n            if (!camera.isReady(true)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else if (this.activeCamera) {\n        if (!this.activeCamera.isReady(true)) {\n          return false;\n        }\n      }\n      // Particles\n      var _iterator6 = _createForOfIteratorHelper(this.particleSystems),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var particleSystem = _step6.value;\n          if (!particleSystem.isReady()) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return true;\n    }\n    /** Resets all cached information relative to material (including effect and visibility) */\n  }, {\n    key: \"resetCachedMaterial\",\n    value: function resetCachedMaterial() {\n      this._cachedMaterial = null;\n      this._cachedEffect = null;\n      this._cachedVisibility = null;\n    }\n    /**\n     * Registers a function to be called before every frame render\n     * @param func defines the function to register\n     */\n  }, {\n    key: \"registerBeforeRender\",\n    value: function registerBeforeRender(func) {\n      this.onBeforeRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called before every frame render\n     * @param func defines the function to unregister\n     */\n  }, {\n    key: \"unregisterBeforeRender\",\n    value: function unregisterBeforeRender(func) {\n      this.onBeforeRenderObservable.removeCallback(func);\n    }\n    /**\n     * Registers a function to be called after every frame render\n     * @param func defines the function to register\n     */\n  }, {\n    key: \"registerAfterRender\",\n    value: function registerAfterRender(func) {\n      this.onAfterRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called after every frame render\n     * @param func defines the function to unregister\n     */\n  }, {\n    key: \"unregisterAfterRender\",\n    value: function unregisterAfterRender(func) {\n      this.onAfterRenderObservable.removeCallback(func);\n    }\n  }, {\n    key: \"_executeOnceBeforeRender\",\n    value: function _executeOnceBeforeRender(func) {\n      var _this3 = this;\n      var execFunc = function execFunc() {\n        func();\n        setTimeout(function () {\n          _this3.unregisterBeforeRender(execFunc);\n        });\n      };\n      this.registerBeforeRender(execFunc);\n    }\n    /**\n     * The provided function will run before render once and will be disposed afterwards.\n     * A timeout delay can be provided so that the function will be executed in N ms.\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n     * @param func The function to be executed.\n     * @param timeout optional delay in ms\n     */\n  }, {\n    key: \"executeOnceBeforeRender\",\n    value: function executeOnceBeforeRender(func, timeout) {\n      var _this4 = this;\n      if (timeout !== undefined) {\n        setTimeout(function () {\n          _this4._executeOnceBeforeRender(func);\n        }, timeout);\n      } else {\n        this._executeOnceBeforeRender(func);\n      }\n    }\n    /**\n     * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n     * @param data defines the object to wait for\n     */\n  }, {\n    key: \"addPendingData\",\n    value: function addPendingData(data) {\n      this._pendingData.push(data);\n    }\n    /**\n     * Remove a pending data from the loading list which has previously been added with addPendingData.\n     * @param data defines the object to remove from the pending list\n     */\n  }, {\n    key: \"removePendingData\",\n    value: function removePendingData(data) {\n      var wasLoading = this.isLoading;\n      var index = this._pendingData.indexOf(data);\n      if (index !== -1) {\n        this._pendingData.splice(index, 1);\n      }\n      if (wasLoading && !this.isLoading) {\n        this.onDataLoadedObservable.notifyObservers(this);\n      }\n    }\n    /**\n     * Returns the number of items waiting to be loaded\n     * @returns the number of items waiting to be loaded\n     */\n  }, {\n    key: \"getWaitingItemsCount\",\n    value: function getWaitingItemsCount() {\n      return this._pendingData.length;\n    }\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._pendingData.length > 0;\n    }\n    /**\n     * Registers a function to be executed when the scene is ready\n     * @param func - the function to be executed\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     */\n  }, {\n    key: \"executeWhenReady\",\n    value: function executeWhenReady(func) {\n      var checkRenderTargets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.onReadyObservable.addOnce(func);\n      if (this._executeWhenReadyTimeoutId !== null) {\n        return;\n      }\n      this._checkIsReady(checkRenderTargets);\n    }\n    /**\n     * Returns a promise that resolves when the scene is ready\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     * @returns A promise that resolves when the scene is ready\n     */\n  }, {\n    key: \"whenReadyAsync\",\n    value: function whenReadyAsync() {\n      var _this5 = this;\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return new Promise(function (resolve) {\n        _this5.executeWhenReady(function () {\n          resolve();\n        }, checkRenderTargets);\n      });\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_checkIsReady\",\n    value: function _checkIsReady() {\n      var _this6 = this;\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._registerTransientComponents();\n      if (this.isReady(checkRenderTargets)) {\n        this.onReadyObservable.notifyObservers(this);\n        this.onReadyObservable.clear();\n        this._executeWhenReadyTimeoutId = null;\n        return;\n      }\n      if (this._isDisposed) {\n        this.onReadyObservable.clear();\n        this._executeWhenReadyTimeoutId = null;\n        return;\n      }\n      this._executeWhenReadyTimeoutId = setTimeout(function () {\n        // Ensure materials effects are checked outside render loops\n        _this6.incrementRenderId();\n        _this6._checkIsReady(checkRenderTargets);\n      }, 100);\n    }\n    /**\n     * Gets all animatable attached to the scene\n     */\n  }, {\n    key: \"animatables\",\n    get: function get() {\n      return this._activeAnimatables;\n    }\n    /**\n     * Resets the last animation time frame.\n     * Useful to override when animations start running when loading a scene for the first time.\n     */\n  }, {\n    key: \"resetLastAnimationTimeFrame\",\n    value: function resetLastAnimationTimeFrame() {\n      this._animationTimeLast = PrecisionDate.Now;\n    }\n    // Matrix\n    /**\n     * Gets the current view matrix\n     * @returns a Matrix\n     */\n  }, {\n    key: \"getViewMatrix\",\n    value: function getViewMatrix() {\n      return this._viewMatrix;\n    }\n    /**\n     * Gets the current projection matrix\n     * @returns a Matrix\n     */\n  }, {\n    key: \"getProjectionMatrix\",\n    value: function getProjectionMatrix() {\n      return this._projectionMatrix;\n    }\n    /**\n     * Gets the current transform matrix\n     * @returns a Matrix made of View * Projection\n     */\n  }, {\n    key: \"getTransformMatrix\",\n    value: function getTransformMatrix() {\n      return this._transformMatrix;\n    }\n    /**\n     * Sets the current transform matrix\n     * @param viewL defines the View matrix to use\n     * @param projectionL defines the Projection matrix to use\n     * @param viewR defines the right View matrix to use (if provided)\n     * @param projectionR defines the right Projection matrix to use (if provided)\n     */\n  }, {\n    key: \"setTransformMatrix\",\n    value: function setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n      // clear the multiviewSceneUbo if no viewR and projectionR are defined\n      if (!viewR && !projectionR && this._multiviewSceneUbo) {\n        this._multiviewSceneUbo.dispose();\n        this._multiviewSceneUbo = null;\n      }\n      if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n        return;\n      }\n      this._viewUpdateFlag = viewL.updateFlag;\n      this._projectionUpdateFlag = projectionL.updateFlag;\n      this._viewMatrix = viewL;\n      this._projectionMatrix = projectionL;\n      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n      // Update frustum\n      if (!this._frustumPlanes) {\n        this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n      } else {\n        Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n      }\n      if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n        this._updateMultiviewUbo(viewR, projectionR);\n      } else if (this._sceneUbo.useUbo) {\n        this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n        this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n        this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n      }\n    }\n    /**\n     * Gets the uniform buffer used to store scene data\n     * @returns a UniformBuffer\n     */\n  }, {\n    key: \"getSceneUniformBuffer\",\n    value: function getSceneUniformBuffer() {\n      return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n    }\n    /**\n     * Creates a scene UBO\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\n     * @returns a new ubo\n     */\n  }, {\n    key: \"createSceneUniformBuffer\",\n    value: function createSceneUniformBuffer(name) {\n      var sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n      sceneUbo.addUniform(\"viewProjection\", 16);\n      sceneUbo.addUniform(\"view\", 16);\n      sceneUbo.addUniform(\"projection\", 16);\n      sceneUbo.addUniform(\"vEyePosition\", 4);\n      return sceneUbo;\n    }\n    /**\n     * Sets the scene ubo\n     * @param ubo the ubo to set for the scene\n     */\n  }, {\n    key: \"setSceneUniformBuffer\",\n    value: function setSceneUniformBuffer(ubo) {\n      this._sceneUbo = ubo;\n      this._viewUpdateFlag = -1;\n      this._projectionUpdateFlag = -1;\n    }\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     * @returns an unique number for the scene\n     */\n  }, {\n    key: \"getUniqueId\",\n    value: function getUniqueId() {\n      return UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Add a mesh to the list of scene's meshes\n     * @param newMesh defines the mesh to add\n     * @param recursive if all child meshes should also be added to the scene\n     */\n  }, {\n    key: \"addMesh\",\n    value: function addMesh(newMesh) {\n      var _this7 = this;\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.meshes.push(newMesh);\n      newMesh._resyncLightSources();\n      if (!newMesh.parent) {\n        newMesh._addToSceneRootNodes();\n      }\n      this.onNewMeshAddedObservable.notifyObservers(newMesh);\n      if (recursive) {\n        newMesh.getChildMeshes().forEach(function (m) {\n          _this7.addMesh(m);\n        });\n      }\n    }\n    /**\n     * Remove a mesh for the list of scene's meshes\n     * @param toRemove defines the mesh to remove\n     * @param recursive if all child meshes should also be removed from the scene\n     * @returns the index where the mesh was in the mesh list\n     */\n  }, {\n    key: \"removeMesh\",\n    value: function removeMesh(toRemove) {\n      var _this8 = this;\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = this.meshes.indexOf(toRemove);\n      if (index !== -1) {\n        // Remove from the scene if mesh found\n        this.meshes[index] = this.meshes[this.meshes.length - 1];\n        this.meshes.pop();\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n      this._inputManager._invalidateMesh(toRemove);\n      this.onMeshRemovedObservable.notifyObservers(toRemove);\n      if (recursive) {\n        toRemove.getChildMeshes().forEach(function (m) {\n          _this8.removeMesh(m);\n        });\n      }\n      return index;\n    }\n    /**\n     * Add a transform node to the list of scene's transform nodes\n     * @param newTransformNode defines the transform node to add\n     */\n  }, {\n    key: \"addTransformNode\",\n    value: function addTransformNode(newTransformNode) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n        // Already there?\n        return;\n      }\n      newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n      this.transformNodes.push(newTransformNode);\n      if (!newTransformNode.parent) {\n        newTransformNode._addToSceneRootNodes();\n      }\n      this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n    }\n    /**\n     * Remove a transform node for the list of scene's transform nodes\n     * @param toRemove defines the transform node to remove\n     * @returns the index where the transform node was in the transform node list\n     */\n  }, {\n    key: \"removeTransformNode\",\n    value: function removeTransformNode(toRemove) {\n      var index = toRemove._indexInSceneTransformNodesArray;\n      if (index !== -1) {\n        if (index !== this.transformNodes.length - 1) {\n          var lastNode = this.transformNodes[this.transformNodes.length - 1];\n          this.transformNodes[index] = lastNode;\n          lastNode._indexInSceneTransformNodesArray = index;\n        }\n        toRemove._indexInSceneTransformNodesArray = -1;\n        this.transformNodes.pop();\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n      this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a skeleton for the list of scene's skeletons\n     * @param toRemove defines the skeleton to remove\n     * @returns the index where the skeleton was in the skeleton list\n     */\n  }, {\n    key: \"removeSkeleton\",\n    value: function removeSkeleton(toRemove) {\n      var index = this.skeletons.indexOf(toRemove);\n      if (index !== -1) {\n        // Remove from the scene if found\n        this.skeletons.splice(index, 1);\n        this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n        // Clean active container\n        this._executeActiveContainerCleanup(this._activeSkeletons);\n      }\n      return index;\n    }\n    /**\n     * Remove a morph target for the list of scene's morph targets\n     * @param toRemove defines the morph target to remove\n     * @returns the index where the morph target was in the morph target list\n     */\n  }, {\n    key: \"removeMorphTargetManager\",\n    value: function removeMorphTargetManager(toRemove) {\n      var index = this.morphTargetManagers.indexOf(toRemove);\n      if (index !== -1) {\n        // Remove from the scene if found\n        this.morphTargetManagers.splice(index, 1);\n      }\n      return index;\n    }\n    /**\n     * Remove a light for the list of scene's lights\n     * @param toRemove defines the light to remove\n     * @returns the index where the light was in the light list\n     */\n  }, {\n    key: \"removeLight\",\n    value: function removeLight(toRemove) {\n      var index = this.lights.indexOf(toRemove);\n      if (index !== -1) {\n        // Remove from meshes\n        var _iterator7 = _createForOfIteratorHelper(this.meshes),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var mesh = _step7.value;\n            mesh._removeLightSource(toRemove, false);\n          }\n          // Remove from the scene if mesh found\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        this.lights.splice(index, 1);\n        this.sortLightsByPriority();\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n      this.onLightRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a camera for the list of scene's cameras\n     * @param toRemove defines the camera to remove\n     * @returns the index where the camera was in the camera list\n     */\n  }, {\n    key: \"removeCamera\",\n    value: function removeCamera(toRemove) {\n      var index = this.cameras.indexOf(toRemove);\n      if (index !== -1) {\n        // Remove from the scene if mesh found\n        this.cameras.splice(index, 1);\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n      // Remove from activeCameras\n      if (this.activeCameras) {\n        var index2 = this.activeCameras.indexOf(toRemove);\n        if (index2 !== -1) {\n          // Remove from the scene if mesh found\n          this.activeCameras.splice(index2, 1);\n        }\n      }\n      // Reset the activeCamera\n      if (this.activeCamera === toRemove) {\n        if (this.cameras.length > 0) {\n          this.activeCamera = this.cameras[0];\n        } else {\n          this.activeCamera = null;\n        }\n      }\n      this.onCameraRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a particle system for the list of scene's particle systems\n     * @param toRemove defines the particle system to remove\n     * @returns the index where the particle system was in the particle system list\n     */\n  }, {\n    key: \"removeParticleSystem\",\n    value: function removeParticleSystem(toRemove) {\n      var index = this.particleSystems.indexOf(toRemove);\n      if (index !== -1) {\n        this.particleSystems.splice(index, 1);\n        // Clean active container\n        this._executeActiveContainerCleanup(this._activeParticleSystems);\n      }\n      return index;\n    }\n    /**\n     * Remove a animation for the list of scene's animations\n     * @param toRemove defines the animation to remove\n     * @returns the index where the animation was in the animation list\n     */\n  }, {\n    key: \"removeAnimation\",\n    value: function removeAnimation(toRemove) {\n      var index = this.animations.indexOf(toRemove);\n      if (index !== -1) {\n        this.animations.splice(index, 1);\n      }\n      return index;\n    }\n    /**\n     * Will stop the animation of the given target\n     * @param target - the target\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     */\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(target, animationName, targetMask) {\n      // Do nothing as code will be provided by animation component\n    }\n    /**\n     * Removes the given animation group from this scene.\n     * @param toRemove The animation group to remove\n     * @returns The index of the removed animation group\n     */\n  }, {\n    key: \"removeAnimationGroup\",\n    value: function removeAnimationGroup(toRemove) {\n      var index = this.animationGroups.indexOf(toRemove);\n      if (index !== -1) {\n        this.animationGroups.splice(index, 1);\n      }\n      return index;\n    }\n    /**\n     * Removes the given multi-material from this scene.\n     * @param toRemove The multi-material to remove\n     * @returns The index of the removed multi-material\n     */\n  }, {\n    key: \"removeMultiMaterial\",\n    value: function removeMultiMaterial(toRemove) {\n      var index = this.multiMaterials.indexOf(toRemove);\n      if (index !== -1) {\n        this.multiMaterials.splice(index, 1);\n      }\n      this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Removes the given material from this scene.\n     * @param toRemove The material to remove\n     * @returns The index of the removed material\n     */\n  }, {\n    key: \"removeMaterial\",\n    value: function removeMaterial(toRemove) {\n      var index = toRemove._indexInSceneMaterialArray;\n      if (index !== -1 && index < this.materials.length) {\n        if (index !== this.materials.length - 1) {\n          var lastMaterial = this.materials[this.materials.length - 1];\n          this.materials[index] = lastMaterial;\n          lastMaterial._indexInSceneMaterialArray = index;\n        }\n        toRemove._indexInSceneMaterialArray = -1;\n        this.materials.pop();\n      }\n      this.onMaterialRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Removes the given action manager from this scene.\n     * @deprecated\n     * @param toRemove The action manager to remove\n     * @returns The index of the removed action manager\n     */\n  }, {\n    key: \"removeActionManager\",\n    value: function removeActionManager(toRemove) {\n      var index = this.actionManagers.indexOf(toRemove);\n      if (index !== -1) {\n        this.actionManagers.splice(index, 1);\n      }\n      return index;\n    }\n    /**\n     * Removes the given texture from this scene.\n     * @param toRemove The texture to remove\n     * @returns The index of the removed texture\n     */\n  }, {\n    key: \"removeTexture\",\n    value: function removeTexture(toRemove) {\n      var index = this.textures.indexOf(toRemove);\n      if (index !== -1) {\n        this.textures.splice(index, 1);\n      }\n      this.onTextureRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Adds the given light to this scene\n     * @param newLight The light to add\n     */\n  }, {\n    key: \"addLight\",\n    value: function addLight(newLight) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.lights.push(newLight);\n      this.sortLightsByPriority();\n      if (!newLight.parent) {\n        newLight._addToSceneRootNodes();\n      }\n      // Add light to all meshes (To support if the light is removed and then re-added)\n      var _iterator8 = _createForOfIteratorHelper(this.meshes),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var mesh = _step8.value;\n          if (mesh.lightSources.indexOf(newLight) === -1) {\n            mesh.lightSources.push(newLight);\n            mesh._resyncLightSources();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      this.onNewLightAddedObservable.notifyObservers(newLight);\n    }\n    /**\n     * Sorts the list list based on light priorities\n     */\n  }, {\n    key: \"sortLightsByPriority\",\n    value: function sortLightsByPriority() {\n      if (this.requireLightSorting) {\n        this.lights.sort(LightConstants.CompareLightsPriority);\n      }\n    }\n    /**\n     * Adds the given camera to this scene\n     * @param newCamera The camera to add\n     */\n  }, {\n    key: \"addCamera\",\n    value: function addCamera(newCamera) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.cameras.push(newCamera);\n      this.onNewCameraAddedObservable.notifyObservers(newCamera);\n      if (!newCamera.parent) {\n        newCamera._addToSceneRootNodes();\n      }\n    }\n    /**\n     * Adds the given skeleton to this scene\n     * @param newSkeleton The skeleton to add\n     */\n  }, {\n    key: \"addSkeleton\",\n    value: function addSkeleton(newSkeleton) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.skeletons.push(newSkeleton);\n      this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n    }\n    /**\n     * Adds the given particle system to this scene\n     * @param newParticleSystem The particle system to add\n     */\n  }, {\n    key: \"addParticleSystem\",\n    value: function addParticleSystem(newParticleSystem) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.particleSystems.push(newParticleSystem);\n    }\n    /**\n     * Adds the given animation to this scene\n     * @param newAnimation The animation to add\n     */\n  }, {\n    key: \"addAnimation\",\n    value: function addAnimation(newAnimation) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.animations.push(newAnimation);\n    }\n    /**\n     * Adds the given animation group to this scene.\n     * @param newAnimationGroup The animation group to add\n     */\n  }, {\n    key: \"addAnimationGroup\",\n    value: function addAnimationGroup(newAnimationGroup) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.animationGroups.push(newAnimationGroup);\n    }\n    /**\n     * Adds the given multi-material to this scene\n     * @param newMultiMaterial The multi-material to add\n     */\n  }, {\n    key: \"addMultiMaterial\",\n    value: function addMultiMaterial(newMultiMaterial) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.multiMaterials.push(newMultiMaterial);\n      this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n    }\n    /**\n     * Adds the given material to this scene\n     * @param newMaterial The material to add\n     */\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(newMaterial) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n        // Already there??\n        return;\n      }\n      newMaterial._indexInSceneMaterialArray = this.materials.length;\n      this.materials.push(newMaterial);\n      this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n    }\n    /**\n     * Adds the given morph target to this scene\n     * @param newMorphTargetManager The morph target to add\n     */\n  }, {\n    key: \"addMorphTargetManager\",\n    value: function addMorphTargetManager(newMorphTargetManager) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.morphTargetManagers.push(newMorphTargetManager);\n    }\n    /**\n     * Adds the given geometry to this scene\n     * @param newGeometry The geometry to add\n     */\n  }, {\n    key: \"addGeometry\",\n    value: function addGeometry(newGeometry) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      if (this._geometriesByUniqueId) {\n        this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n      }\n      this.geometries.push(newGeometry);\n    }\n    /**\n     * Adds the given action manager to this scene\n     * @deprecated\n     * @param newActionManager The action manager to add\n     */\n  }, {\n    key: \"addActionManager\",\n    value: function addActionManager(newActionManager) {\n      this.actionManagers.push(newActionManager);\n    }\n    /**\n     * Adds the given texture to this scene.\n     * @param newTexture The texture to add\n     */\n  }, {\n    key: \"addTexture\",\n    value: function addTexture(newTexture) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n      this.textures.push(newTexture);\n      this.onNewTextureAddedObservable.notifyObservers(newTexture);\n    }\n    /**\n     * Switch active camera\n     * @param newCamera defines the new active camera\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n     */\n  }, {\n    key: \"switchActiveCamera\",\n    value: function switchActiveCamera(newCamera) {\n      var attachControl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var canvas = this._engine.getInputElement();\n      if (!canvas) {\n        return;\n      }\n      if (this.activeCamera) {\n        this.activeCamera.detachControl();\n      }\n      this.activeCamera = newCamera;\n      if (attachControl) {\n        newCamera.attachControl();\n      }\n    }\n    /**\n     * sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @returns the new active camera or null if none found.\n     */\n  }, {\n    key: \"setActiveCameraById\",\n    value: function setActiveCameraById(id) {\n      var camera = this.getCameraById(id);\n      if (camera) {\n        this.activeCamera = camera;\n        return camera;\n      }\n      return null;\n    }\n    /**\n     * sets the active camera of the scene using its name\n     * @param name defines the camera's name\n     * @returns the new active camera or null if none found.\n     */\n  }, {\n    key: \"setActiveCameraByName\",\n    value: function setActiveCameraByName(name) {\n      var camera = this.getCameraByName(name);\n      if (camera) {\n        this.activeCamera = camera;\n        return camera;\n      }\n      return null;\n    }\n    /**\n     * get an animation group using its name\n     * @param name defines the material's name\n     * @returns the animation group or null if none found.\n     */\n  }, {\n    key: \"getAnimationGroupByName\",\n    value: function getAnimationGroupByName(name) {\n      for (var index = 0; index < this.animationGroups.length; index++) {\n        if (this.animationGroups[index].name === name) {\n          return this.animationGroups[index];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_getMaterial\",\n    value: function _getMaterial(allowMultiMaterials, predicate) {\n      for (var index = 0; index < this.materials.length; index++) {\n        var material = this.materials[index];\n        if (predicate(material)) {\n          return material;\n        }\n      }\n      if (allowMultiMaterials) {\n        for (var _index = 0; _index < this.multiMaterials.length; _index++) {\n          var _material = this.multiMaterials[_index];\n          if (predicate(_material)) {\n            return _material;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Get a material using its unique id\n     * @param uniqueId defines the material's unique id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n  }, {\n    key: \"getMaterialByUniqueID\",\n    value: function getMaterialByUniqueID(uniqueId) {\n      var allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this._getMaterial(allowMultiMaterials, function (m) {\n        return m.uniqueId === uniqueId;\n      });\n    }\n    /**\n     * get a material using its id\n     * @param id defines the material's Id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n  }, {\n    key: \"getMaterialById\",\n    value: function getMaterialById(id) {\n      var allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this._getMaterial(allowMultiMaterials, function (m) {\n        return m.id === id;\n      });\n    }\n    /**\n     * Gets a material using its name\n     * @param name defines the material's name\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      var allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this._getMaterial(allowMultiMaterials, function (m) {\n        return m.name === name;\n      });\n    }\n    /**\n     * Gets a last added material using a given id\n     * @param id defines the material's id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the last material with the given id or null if none found.\n     */\n  }, {\n    key: \"getLastMaterialById\",\n    value: function getLastMaterialById(id) {\n      var allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      for (var index = this.materials.length - 1; index >= 0; index--) {\n        if (this.materials[index].id === id) {\n          return this.materials[index];\n        }\n      }\n      if (allowMultiMaterials) {\n        for (var _index2 = this.multiMaterials.length - 1; _index2 >= 0; _index2--) {\n          if (this.multiMaterials[_index2].id === id) {\n            return this.multiMaterials[_index2];\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @returns the texture or null if none found.\n     */\n  }, {\n    key: \"getTextureByUniqueId\",\n    value: function getTextureByUniqueId(uniqueId) {\n      for (var index = 0; index < this.textures.length; index++) {\n        if (this.textures[index].uniqueId === uniqueId) {\n          return this.textures[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a texture using its name\n     * @param name defines the texture's name\n     * @returns the texture or null if none found.\n     */\n  }, {\n    key: \"getTextureByName\",\n    value: function getTextureByName(name) {\n      for (var index = 0; index < this.textures.length; index++) {\n        if (this.textures[index].name === name) {\n          return this.textures[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     */\n  }, {\n    key: \"getCameraById\",\n    value: function getCameraById(id) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].id === id) {\n          return this.cameras[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     */\n  }, {\n    key: \"getCameraByUniqueId\",\n    value: function getCameraByUniqueId(uniqueId) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].uniqueId === uniqueId) {\n          return this.cameras[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a camera using its name\n     * @param name defines the camera's name\n     * @returns the camera or null if none found.\n     */\n  }, {\n    key: \"getCameraByName\",\n    value: function getCameraByName(name) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].name === name) {\n          return this.cameras[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @returns the bone or null if not found\n     */\n  }, {\n    key: \"getBoneById\",\n    value: function getBoneById(id) {\n      for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n        var skeleton = this.skeletons[skeletonIndex];\n        for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n          if (skeleton.bones[boneIndex].id === id) {\n            return skeleton.bones[boneIndex];\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a bone using its id\n     * @param name defines the bone's name\n     * @returns the bone or null if not found\n     */\n  }, {\n    key: \"getBoneByName\",\n    value: function getBoneByName(name) {\n      for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n        var skeleton = this.skeletons[skeletonIndex];\n        for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n          if (skeleton.bones[boneIndex].name === name) {\n            return skeleton.bones[boneIndex];\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a light node using its name\n     * @param name defines the the light's name\n     * @returns the light or null if none found.\n     */\n  }, {\n    key: \"getLightByName\",\n    value: function getLightByName(name) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].name === name) {\n          return this.lights[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @returns the light or null if none found.\n     */\n  }, {\n    key: \"getLightById\",\n    value: function getLightById(id) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].id === id) {\n          return this.lights[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @returns the light or null if none found.\n     */\n  }, {\n    key: \"getLightByUniqueId\",\n    value: function getLightByUniqueId(uniqueId) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].uniqueId === uniqueId) {\n          return this.lights[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @returns the corresponding system or null if none found\n     */\n  }, {\n    key: \"getParticleSystemById\",\n    value: function getParticleSystemById(id) {\n      for (var index = 0; index < this.particleSystems.length; index++) {\n        if (this.particleSystems[index].id === id) {\n          return this.particleSystems[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @returns the geometry or null if none found.\n     */\n  }, {\n    key: \"getGeometryById\",\n    value: function getGeometryById(id) {\n      for (var index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].id === id) {\n          return this.geometries[index];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_getGeometryByUniqueId\",\n    value: function _getGeometryByUniqueId(uniqueId) {\n      if (this._geometriesByUniqueId) {\n        var index = this._geometriesByUniqueId[uniqueId];\n        if (index !== undefined) {\n          return this.geometries[index];\n        }\n      } else {\n        for (var _index3 = 0; _index3 < this.geometries.length; _index3++) {\n          if (this.geometries[_index3].uniqueId === uniqueId) {\n            return this.geometries[_index3];\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Add a new geometry to this scene\n     * @param geometry defines the geometry to be added to the scene.\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n     * @returns a boolean defining if the geometry was added or not\n     */\n  }, {\n    key: \"pushGeometry\",\n    value: function pushGeometry(geometry, force) {\n      if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n        return false;\n      }\n      this.addGeometry(geometry);\n      this.onNewGeometryAddedObservable.notifyObservers(geometry);\n      return true;\n    }\n    /**\n     * Removes an existing geometry\n     * @param geometry defines the geometry to be removed from the scene\n     * @returns a boolean defining if the geometry was removed or not\n     */\n  }, {\n    key: \"removeGeometry\",\n    value: function removeGeometry(geometry) {\n      var index;\n      if (this._geometriesByUniqueId) {\n        index = this._geometriesByUniqueId[geometry.uniqueId];\n        if (index === undefined) {\n          return false;\n        }\n      } else {\n        index = this.geometries.indexOf(geometry);\n        if (index < 0) {\n          return false;\n        }\n      }\n      if (index !== this.geometries.length - 1) {\n        var lastGeometry = this.geometries[this.geometries.length - 1];\n        if (lastGeometry) {\n          this.geometries[index] = lastGeometry;\n          if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n          }\n        }\n      }\n      if (this._geometriesByUniqueId) {\n        this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n      }\n      this.geometries.pop();\n      this.onGeometryRemovedObservable.notifyObservers(geometry);\n      return true;\n    }\n    /**\n     * Gets the list of geometries attached to the scene\n     * @returns an array of Geometry\n     */\n  }, {\n    key: \"getGeometries\",\n    value: function getGeometries() {\n      return this.geometries;\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @returns the mesh found or null if not found at all\n     */\n  }, {\n    key: \"getMeshById\",\n    value: function getMeshById(id) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     */\n  }, {\n    key: \"getMeshesById\",\n    value: function getMeshesById(id) {\n      return this.meshes.filter(function (m) {\n        return m.id === id;\n      });\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n  }, {\n    key: \"getTransformNodeById\",\n    value: function getTransformNodeById(id) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].id === id) {\n          return this.transformNodes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n  }, {\n    key: \"getTransformNodeByUniqueId\",\n    value: function getTransformNodeByUniqueId(uniqueId) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].uniqueId === uniqueId) {\n          return this.transformNodes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     */\n  }, {\n    key: \"getTransformNodesById\",\n    value: function getTransformNodesById(id) {\n      return this.transformNodes.filter(function (m) {\n        return m.id === id;\n      });\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n  }, {\n    key: \"getMeshByUniqueId\",\n    value: function getMeshByUniqueId(uniqueId) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].uniqueId === uniqueId) {\n          return this.meshes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n  }, {\n    key: \"getLastMeshById\",\n    value: function getLastMeshById(id) {\n      for (var index = this.meshes.length - 1; index >= 0; index--) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n  }, {\n    key: \"getLastEntryById\",\n    value: function getLastEntryById(id) {\n      var index;\n      for (index = this.meshes.length - 1; index >= 0; index--) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n      for (index = this.transformNodes.length - 1; index >= 0; index--) {\n        if (this.transformNodes[index].id === id) {\n          return this.transformNodes[index];\n        }\n      }\n      for (index = this.cameras.length - 1; index >= 0; index--) {\n        if (this.cameras[index].id === id) {\n          return this.cameras[index];\n        }\n      }\n      for (index = this.lights.length - 1; index >= 0; index--) {\n        if (this.lights[index].id === id) {\n          return this.lights[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      var mesh = this.getMeshById(id);\n      if (mesh) {\n        return mesh;\n      }\n      var transformNode = this.getTransformNodeById(id);\n      if (transformNode) {\n        return transformNode;\n      }\n      var light = this.getLightById(id);\n      if (light) {\n        return light;\n      }\n      var camera = this.getCameraById(id);\n      if (camera) {\n        return camera;\n      }\n      var bone = this.getBoneById(id);\n      if (bone) {\n        return bone;\n      }\n      return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given name\n     * @param name defines the name to search for\n     * @returns the found node or null if not found at all.\n     */\n  }, {\n    key: \"getNodeByName\",\n    value: function getNodeByName(name) {\n      var mesh = this.getMeshByName(name);\n      if (mesh) {\n        return mesh;\n      }\n      var transformNode = this.getTransformNodeByName(name);\n      if (transformNode) {\n        return transformNode;\n      }\n      var light = this.getLightByName(name);\n      if (light) {\n        return light;\n      }\n      var camera = this.getCameraByName(name);\n      if (camera) {\n        return camera;\n      }\n      var bone = this.getBoneByName(name);\n      if (bone) {\n        return bone;\n      }\n      return null;\n    }\n    /**\n     * Gets a mesh using a given name\n     * @param name defines the name to search for\n     * @returns the found mesh or null if not found at all.\n     */\n  }, {\n    key: \"getMeshByName\",\n    value: function getMeshByName(name) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].name === name) {\n          return this.meshes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a transform node using a given name\n     * @param name defines the name to search for\n     * @returns the found transform node or null if not found at all.\n     */\n  }, {\n    key: \"getTransformNodeByName\",\n    value: function getTransformNodeByName(name) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].name === name) {\n          return this.transformNodes[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n  }, {\n    key: \"getLastSkeletonById\",\n    value: function getLastSkeletonById(id) {\n      for (var index = this.skeletons.length - 1; index >= 0; index--) {\n        if (this.skeletons[index].id === id) {\n          return this.skeletons[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given auto generated unique id\n     * @param  uniqueId defines the unique id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n  }, {\n    key: \"getSkeletonByUniqueId\",\n    value: function getSkeletonByUniqueId(uniqueId) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].uniqueId === uniqueId) {\n          return this.skeletons[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n  }, {\n    key: \"getSkeletonById\",\n    value: function getSkeletonById(id) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].id === id) {\n          return this.skeletons[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given name\n     * @param name defines the name to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n  }, {\n    key: \"getSkeletonByName\",\n    value: function getSkeletonByName(name) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].name === name) {\n          return this.skeletons[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n     * @param id defines the id to search for\n     * @returns the found morph target manager or null if not found at all.\n     */\n  }, {\n    key: \"getMorphTargetManagerById\",\n    value: function getMorphTargetManagerById(id) {\n      for (var index = 0; index < this.morphTargetManagers.length; index++) {\n        if (this.morphTargetManagers[index].uniqueId === id) {\n          return this.morphTargetManagers[index];\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found morph target or null if not found at all.\n     */\n  }, {\n    key: \"getMorphTargetById\",\n    value: function getMorphTargetById(id) {\n      for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n        var morphTargetManager = this.morphTargetManagers[managerIndex];\n        for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n          var target = morphTargetManager.getTarget(index);\n          if (target.id === id) {\n            return target;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found morph target or null if not found at all.\n     */\n  }, {\n    key: \"getMorphTargetByName\",\n    value: function getMorphTargetByName(name) {\n      for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n        var morphTargetManager = this.morphTargetManagers[managerIndex];\n        for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n          var target = morphTargetManager.getTarget(index);\n          if (target.name === name) {\n            return target;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found post process or null if not found at all.\n     */\n  }, {\n    key: \"getPostProcessByName\",\n    value: function getPostProcessByName(name) {\n      for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n        var postProcess = this.postProcesses[postProcessIndex];\n        if (postProcess.name === name) {\n          return postProcess;\n        }\n      }\n      return null;\n    }\n    /**\n     * Gets a boolean indicating if the given mesh is active\n     * @param mesh defines the mesh to look for\n     * @returns true if the mesh is in the active list\n     */\n  }, {\n    key: \"isActiveMesh\",\n    value: function isActiveMesh(mesh) {\n      return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n  }, {\n    key: \"uid\",\n    get: function get() {\n      if (!this._uid) {\n        this._uid = Tools.RandomId();\n      }\n      return this._uid;\n    }\n    /**\n     * Add an externally attached data from its key.\n     * This method call will fail and return false, if such key already exists.\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n     * @param key the unique key that identifies the data\n     * @param data the data object to associate to the key for this Engine instance\n     * @returns true if no such key were already present and the data was added successfully, false otherwise\n     */\n  }, {\n    key: \"addExternalData\",\n    value: function addExternalData(key, data) {\n      if (!this._externalData) {\n        this._externalData = new StringDictionary();\n      }\n      return this._externalData.add(key, data);\n    }\n    /**\n     * Get an externally attached data from its key\n     * @param key the unique key that identifies the data\n     * @returns the associated data, if present (can be null), or undefined if not present\n     */\n  }, {\n    key: \"getExternalData\",\n    value: function getExternalData(key) {\n      if (!this._externalData) {\n        return null;\n      }\n      return this._externalData.get(key);\n    }\n    /**\n     * Get an externally attached data from its key, create it using a factory if it's not already present\n     * @param key the unique key that identifies the data\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n     * @returns the associated data, can be null if the factory returned null.\n     */\n  }, {\n    key: \"getOrAddExternalDataWithFactory\",\n    value: function getOrAddExternalDataWithFactory(key, factory) {\n      if (!this._externalData) {\n        this._externalData = new StringDictionary();\n      }\n      return this._externalData.getOrAddWithFactory(key, factory);\n    }\n    /**\n     * Remove an externally attached data from the Engine instance\n     * @param key the unique key that identifies the data\n     * @returns true if the data was successfully removed, false if it doesn't exist\n     */\n  }, {\n    key: \"removeExternalData\",\n    value: function removeExternalData(key) {\n      return this._externalData.remove(key);\n    }\n  }, {\n    key: \"_evaluateSubMesh\",\n    value: function _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {\n      if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\n        var _iterator9 = _createForOfIteratorHelper(this._evaluateSubMeshStage),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var step = _step9.value;\n            step.action(mesh, subMesh);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        var material = subMesh.getMaterial();\n        if (material !== null && material !== undefined) {\n          // Render targets\n          if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n            if (this._processedMaterials.indexOf(material) === -1) {\n              this._processedMaterials.push(material);\n              this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n            }\n          }\n          // Dispatch\n          this._renderingManager.dispatch(subMesh, mesh, material);\n        }\n      }\n    }\n    /**\n     * Clear the processed materials smart array preventing retention point in material dispose.\n     */\n  }, {\n    key: \"freeProcessedMaterials\",\n    value: function freeProcessedMaterials() {\n      this._processedMaterials.dispose();\n    }\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n  }, {\n    key: \"blockfreeActiveMeshesAndRenderingGroups\",\n    get: function get() {\n      return this._preventFreeActiveMeshesAndRenderingGroups;\n    },\n    set: function set(value) {\n      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n        return;\n      }\n      if (value) {\n        this.freeActiveMeshes();\n        this.freeRenderingGroups();\n      }\n      this._preventFreeActiveMeshesAndRenderingGroups = value;\n    }\n    /**\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\n     */\n  }, {\n    key: \"freeActiveMeshes\",\n    value: function freeActiveMeshes() {\n      if (this.blockfreeActiveMeshesAndRenderingGroups) {\n        return;\n      }\n      this._activeMeshes.dispose();\n      if (this.activeCamera && this.activeCamera._activeMeshes) {\n        this.activeCamera._activeMeshes.dispose();\n      }\n      if (this.activeCameras) {\n        for (var i = 0; i < this.activeCameras.length; i++) {\n          var activeCamera = this.activeCameras[i];\n          if (activeCamera && activeCamera._activeMeshes) {\n            activeCamera._activeMeshes.dispose();\n          }\n        }\n      }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n  }, {\n    key: \"freeRenderingGroups\",\n    value: function freeRenderingGroups() {\n      if (this.blockfreeActiveMeshesAndRenderingGroups) {\n        return;\n      }\n      if (this._renderingManager) {\n        this._renderingManager.freeRenderingGroups();\n      }\n      if (this.textures) {\n        for (var i = 0; i < this.textures.length; i++) {\n          var texture = this.textures[i];\n          if (texture && texture.renderList) {\n            texture.freeRenderingGroups();\n          }\n        }\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_isInIntermediateRendering\",\n    value: function _isInIntermediateRendering() {\n      return this._intermediateRendering;\n    }\n    /**\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n     * @param onSuccess optional success callback\n     * @param onError optional error callback\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\n     * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n     * @returns the current scene\n     */\n  }, {\n    key: \"freezeActiveMeshes\",\n    value: function freezeActiveMeshes() {\n      var _this9 = this;\n      var skipEvaluateActiveMeshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var onSuccess = arguments.length > 1 ? arguments[1] : undefined;\n      var onError = arguments.length > 2 ? arguments[2] : undefined;\n      var freezeMeshes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var keepFrustumCulling = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      this.executeWhenReady(function () {\n        if (!_this9.activeCamera) {\n          onError && onError(\"No active camera found\");\n          return;\n        }\n        if (!_this9._frustumPlanes) {\n          _this9.updateTransformMatrix();\n        }\n        _this9._evaluateActiveMeshes();\n        _this9._activeMeshesFrozen = true;\n        _this9._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n        _this9._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n        if (freezeMeshes) {\n          for (var index = 0; index < _this9._activeMeshes.length; index++) {\n            _this9._activeMeshes.data[index]._freeze();\n          }\n        }\n        onSuccess && onSuccess();\n      });\n      return this;\n    }\n    /**\n     * Use this function to restart evaluating active meshes on every frame\n     * @returns the current scene\n     */\n  }, {\n    key: \"unfreezeActiveMeshes\",\n    value: function unfreezeActiveMeshes() {\n      for (var index = 0; index < this.meshes.length; index++) {\n        var mesh = this.meshes[index];\n        if (mesh._internalAbstractMeshDataInfo) {\n          mesh._internalAbstractMeshDataInfo._isActive = false;\n        }\n      }\n      for (var _index4 = 0; _index4 < this._activeMeshes.length; _index4++) {\n        this._activeMeshes.data[_index4]._unFreeze();\n      }\n      this._activeMeshesFrozen = false;\n      return this;\n    }\n  }, {\n    key: \"_executeActiveContainerCleanup\",\n    value: function _executeActiveContainerCleanup(container) {\n      var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n      if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n        return; // Do not execute in frozen mode\n      }\n      // We need to ensure we are not in the rendering loop\n      this.onBeforeRenderObservable.addOnce(function () {\n        return container.dispose();\n      });\n    }\n  }, {\n    key: \"_evaluateActiveMeshes\",\n    value: function _evaluateActiveMeshes() {\n      var _a;\n      if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n        if (this._activeMeshes.length > 0) {\n          (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();\n          this._activeMeshes.reset();\n          this._renderingManager.reset();\n          this._processedMaterials.reset();\n          this._activeParticleSystems.reset();\n          this._activeSkeletons.reset();\n          this._softwareSkinnedMeshes.reset();\n        }\n        return;\n      }\n      if (this._activeMeshesFrozen && this._activeMeshes.length) {\n        if (!this._skipEvaluateActiveMeshesCompletely) {\n          var _len = this._activeMeshes.length;\n          for (var i = 0; i < _len; i++) {\n            var mesh = this._activeMeshes.data[i];\n            mesh.computeWorldMatrix();\n          }\n        }\n        if (this._activeParticleSystems) {\n          var psLength = this._activeParticleSystems.length;\n          for (var _i = 0; _i < psLength; _i++) {\n            this._activeParticleSystems.data[_i].animate();\n          }\n        }\n        this._renderingManager.resetSprites();\n        return;\n      }\n      if (!this.activeCamera) {\n        return;\n      }\n      this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n      this.activeCamera._activeMeshes.reset();\n      this._activeMeshes.reset();\n      this._renderingManager.reset();\n      this._processedMaterials.reset();\n      this._activeParticleSystems.reset();\n      this._activeSkeletons.reset();\n      this._softwareSkinnedMeshes.reset();\n      this._materialsRenderTargets.reset();\n      var _iterator10 = _createForOfIteratorHelper(this._beforeEvaluateActiveMeshStage),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step12 = _step10.value;\n          _step12.action();\n        }\n        // Determine mesh candidates\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      var meshes = this.getActiveMeshCandidates();\n      // Check each mesh\n      var len = meshes.length;\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _mesh = meshes.data[_i2];\n        _mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n        if (_mesh.isBlocked) {\n          continue;\n        }\n        this._totalVertices.addCount(_mesh.getTotalVertices(), false);\n        if (!_mesh.isReady() || !_mesh.isEnabled() || _mesh.scaling.hasAZeroComponent) {\n          continue;\n        }\n        _mesh.computeWorldMatrix();\n        // Intersections\n        if (_mesh.actionManager && _mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n          this._meshesForIntersections.pushNoDuplicate(_mesh);\n        }\n        // Switch to current LOD\n        var meshToRender = this.customLODSelector ? this.customLODSelector(_mesh, this.activeCamera) : _mesh.getLOD(this.activeCamera);\n        _mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n        _mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n        if (meshToRender === undefined || meshToRender === null) {\n          continue;\n        }\n        // Compute world matrix if LOD is billboard\n        if (meshToRender !== _mesh && meshToRender.billboardMode !== 0) {\n          meshToRender.computeWorldMatrix();\n        }\n        _mesh._preActivate();\n        if (_mesh.isVisible && _mesh.visibility > 0 && (_mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || _mesh.alwaysSelectAsActiveMesh || _mesh.isInFrustum(this._frustumPlanes))) {\n          this._activeMeshes.push(_mesh);\n          this.activeCamera._activeMeshes.push(_mesh);\n          if (meshToRender !== _mesh) {\n            meshToRender._activate(this._renderId, false);\n          }\n          var _iterator11 = _createForOfIteratorHelper(this._preActiveMeshStage),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var step = _step11.value;\n              step.action(_mesh);\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n          if (_mesh._activate(this._renderId, false)) {\n            if (!_mesh.isAnInstance) {\n              meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n            } else {\n              if (_mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                meshToRender = _mesh;\n              }\n            }\n            meshToRender._internalAbstractMeshDataInfo._isActive = true;\n            this._activeMesh(_mesh, meshToRender);\n          }\n          _mesh._postActivate();\n        }\n      }\n      this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n      // Particle systems\n      if (this.particlesEnabled) {\n        this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n        for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n          var particleSystem = this.particleSystems[particleIndex];\n          if (!particleSystem.isStarted() || !particleSystem.emitter) {\n            continue;\n          }\n          var emitter = particleSystem.emitter;\n          if (!emitter.position || emitter.isEnabled()) {\n            this._activeParticleSystems.push(particleSystem);\n            particleSystem.animate();\n            this._renderingManager.dispatchParticles(particleSystem);\n          }\n        }\n        this.onAfterParticlesRenderingObservable.notifyObservers(this);\n      }\n    }\n  }, {\n    key: \"_activeMesh\",\n    value: function _activeMesh(sourceMesh, mesh) {\n      if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n        if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n          mesh.skeleton.prepare();\n          this._activeBones.addCount(mesh.skeleton.bones.length, false);\n        }\n        if (!mesh.computeBonesUsingShaders) {\n          this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n        }\n      }\n      var forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\n      if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n        var subMeshes = this.getActiveSubMeshCandidates(mesh);\n        var len = subMeshes.length;\n        forcePush = forcePush || len === 1;\n        for (var i = 0; i < len; i++) {\n          var subMesh = subMeshes.data[i];\n          this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\n        }\n      }\n    }\n    /**\n     * Update the transform matrix to update from the current active camera\n     * @param force defines a boolean used to force the update even if cache is up to date\n     */\n  }, {\n    key: \"updateTransformMatrix\",\n    value: function updateTransformMatrix(force) {\n      if (!this.activeCamera) {\n        return;\n      }\n      if (this.activeCamera._renderingMultiview) {\n        var leftCamera = this.activeCamera._rigCameras[0];\n        var rightCamera = this.activeCamera._rigCameras[1];\n        this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n      } else {\n        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n      }\n    }\n  }, {\n    key: \"_bindFrameBuffer\",\n    value: function _bindFrameBuffer(camera) {\n      var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (camera && camera._multiviewTexture) {\n        camera._multiviewTexture._bindFrameBuffer();\n      } else if (camera && camera.outputRenderTarget) {\n        camera.outputRenderTarget._bindFrameBuffer();\n      } else {\n        if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n          this._engine.restoreDefaultFramebuffer();\n        }\n      }\n      if (clear) {\n        this._clearFrameBuffer(camera);\n      }\n    }\n  }, {\n    key: \"_clearFrameBuffer\",\n    value: function _clearFrameBuffer(camera) {\n      // we assume the framebuffer currently bound is the right one\n      if (camera && camera._multiviewTexture) {\n        // no clearing?\n      } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\n        var rtt = camera.outputRenderTarget;\n        if (rtt.onClearObservable.hasObservers()) {\n          rtt.onClearObservable.notifyObservers(this._engine);\n        } else if (!rtt.skipInitialClear) {\n          if (this.autoClear) {\n            this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n          }\n          rtt._cleared = true;\n        }\n      } else {\n        if (!this._defaultFrameBufferCleared) {\n          this._defaultFrameBufferCleared = true;\n          this._clear();\n        } else {\n          this._engine.clear(null, false, true, true);\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_renderForCamera\",\n    value: function _renderForCamera(camera, rigParent) {\n      var bindFrameBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _a, _b, _c;\n      if (camera && camera._skipRendering) {\n        return;\n      }\n      var engine = this._engine;\n      // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n      this._activeCamera = camera;\n      if (!this.activeCamera) {\n        throw new Error(\"Active camera not set\");\n      }\n      // Viewport\n      engine.setViewport(this.activeCamera.viewport);\n      // Camera\n      this.resetCachedMaterial();\n      this._renderId++;\n      if (!this.prePass && bindFrameBuffer) {\n        var skipInitialClear = true;\n        if (camera._renderingMultiview && camera.outputRenderTarget) {\n          skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n          if (this.autoClear) {\n            this._defaultFrameBufferCleared = false;\n            camera.outputRenderTarget.skipInitialClear = false;\n          }\n        }\n        this._bindFrameBuffer(this._activeCamera);\n        if (camera._renderingMultiview && camera.outputRenderTarget) {\n          camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n        }\n      }\n      this.updateTransformMatrix();\n      this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n      // Meshes\n      this._evaluateActiveMeshes();\n      // Software skinning\n      for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n        var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n        mesh.applySkeleton(mesh.skeleton);\n      }\n      // Render targets\n      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n      this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n      if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n        this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n      }\n      if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n        this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n      }\n      if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n        this._renderTargets.pushNoDuplicate(this.environmentTexture);\n      }\n      // Collects render targets from external components.\n      var _iterator12 = _createForOfIteratorHelper(this._gatherActiveCameraRenderTargetsStage),\n        _step13;\n      try {\n        for (_iterator12.s(); !(_step13 = _iterator12.n()).done;) {\n          var _step18 = _step13.value;\n          _step18.action(this._renderTargets);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      var needRebind = false;\n      if (this.renderTargetsEnabled) {\n        this._intermediateRendering = true;\n        if (this._renderTargets.length > 0) {\n          Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n          for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n            var renderTarget = this._renderTargets.data[renderIndex];\n            if (renderTarget._shouldRender()) {\n              this._renderId++;\n              var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n              renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n              needRebind = true;\n            }\n          }\n          Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n          this._renderId++;\n        }\n        var _iterator13 = _createForOfIteratorHelper(this._cameraDrawRenderTargetStage),\n          _step14;\n        try {\n          for (_iterator13.s(); !(_step14 = _iterator13.n()).done;) {\n            var step = _step14.value;\n            needRebind = step.action(this.activeCamera) || needRebind;\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n        this._intermediateRendering = false;\n      }\n      this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n      // Restore framebuffer after rendering to targets\n      if (needRebind && !this.prePass) {\n        this._bindFrameBuffer(this._activeCamera, false);\n      }\n      this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n      // Prepare Frame\n      if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n        this.postProcessManager._prepareFrame();\n      }\n      // Before Camera Draw\n      var _iterator14 = _createForOfIteratorHelper(this._beforeCameraDrawStage),\n        _step15;\n      try {\n        for (_iterator14.s(); !(_step15 = _iterator14.n()).done;) {\n          var _step19 = _step15.value;\n          _step19.action(this.activeCamera);\n        }\n        // Render\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      this.onBeforeDrawPhaseObservable.notifyObservers(this);\n      if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n        this.finalizeSceneUbo();\n      }\n      this._renderingManager.render(null, null, true, true);\n      this.onAfterDrawPhaseObservable.notifyObservers(this);\n      // After Camera Draw\n      var _iterator15 = _createForOfIteratorHelper(this._afterCameraDrawStage),\n        _step16;\n      try {\n        for (_iterator15.s(); !(_step16 = _iterator15.n()).done;) {\n          var _step20 = _step16.value;\n          _step20.action(this.activeCamera);\n        }\n        // Finalize frame\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      if (this.postProcessManager && !camera._multiviewTexture) {\n        // if the camera has an output render target, render the post process to the render target\n        var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n        this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n      }\n      // After post process\n      var _iterator16 = _createForOfIteratorHelper(this._afterCameraPostProcessStage),\n        _step17;\n      try {\n        for (_iterator16.s(); !(_step17 = _iterator16.n()).done;) {\n          var _step21 = _step17.value;\n          _step21.action(this.activeCamera);\n        }\n        // Reset some special arrays\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n      this._renderTargets.reset();\n      this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n    }\n  }, {\n    key: \"_processSubCameras\",\n    value: function _processSubCameras(camera) {\n      var bindFrameBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n        if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n          this._createMultiviewUbo();\n        }\n        this._renderForCamera(camera, undefined, bindFrameBuffer);\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\n        return;\n      }\n      if (camera._useMultiviewToSingleView) {\n        this._renderMultiviewToSingleView(camera);\n      } else {\n        // rig cameras\n        this.onBeforeCameraRenderObservable.notifyObservers(camera);\n        for (var index = 0; index < camera._rigCameras.length; index++) {\n          this._renderForCamera(camera._rigCameras[index], camera);\n        }\n      }\n      // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n      this._activeCamera = camera;\n      this.updateTransformMatrix();\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n    }\n  }, {\n    key: \"_checkIntersections\",\n    value: function _checkIntersections() {\n      for (var index = 0; index < this._meshesForIntersections.length; index++) {\n        var sourceMesh = this._meshesForIntersections.data[index];\n        if (!sourceMesh.actionManager) {\n          continue;\n        }\n        var _loop = function _loop() {\n          var action = sourceMesh.actionManager.actions[actionIndex];\n          if (action.trigger === 12 || action.trigger === 13) {\n            var parameters = action.getTriggerParameter();\n            var otherMesh = parameters.mesh ? parameters.mesh : parameters;\n            var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n            var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n            if (areIntersecting && currentIntersectionInProgress === -1) {\n              if (action.trigger === 12) {\n                action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                sourceMesh._intersectionsInProgress.push(otherMesh);\n              } else if (action.trigger === 13) {\n                sourceMesh._intersectionsInProgress.push(otherMesh);\n              }\n            } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n              //They intersected, and now they don't.\n              //is this trigger an exit trigger? execute an event.\n              if (action.trigger === 13) {\n                action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n              }\n              //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n              if (!sourceMesh.actionManager.hasSpecificTrigger(13, function (parameter) {\n                var parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n                return otherMesh === parameterMesh;\n              }) || action.trigger === 13) {\n                sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n              }\n            }\n          }\n        };\n        for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n          _loop();\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_advancePhysicsEngineStep\",\n    value: function _advancePhysicsEngineStep(step) {\n      // Do nothing. Code will be replaced if physics engine component is referenced\n    }\n    /** @internal */\n  }, {\n    key: \"_animate\",\n    value: function _animate() {\n      // Nothing to do as long as Animatable have not been imported.\n    }\n    /** Execute all animations (for a frame) */\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      if (this._engine.isDeterministicLockStep()) {\n        var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n        var defaultFrameTime = this._engine.getTimeStep();\n        var defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n        var stepsTaken = 0;\n        var maxSubSteps = this._engine.getLockstepMaxSteps();\n        var internalSteps = Math.floor(deltaTime / defaultFrameTime);\n        internalSteps = Math.min(internalSteps, maxSubSteps);\n        while (deltaTime > 0 && stepsTaken < internalSteps) {\n          this.onBeforeStepObservable.notifyObservers(this);\n          // Animations\n          this._animationRatio = defaultFrameTime * defaultFPS;\n          this._animate();\n          this.onAfterAnimationsObservable.notifyObservers(this);\n          // Physics\n          if (this.physicsEnabled) {\n            this._advancePhysicsEngineStep(defaultFrameTime);\n          }\n          this.onAfterStepObservable.notifyObservers(this);\n          this._currentStepId++;\n          stepsTaken++;\n          deltaTime -= defaultFrameTime;\n        }\n        this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n      } else {\n        // Animations\n        var _deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n        this._animationRatio = _deltaTime * (60.0 / 1000.0);\n        this._animate();\n        this.onAfterAnimationsObservable.notifyObservers(this);\n        // Physics\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(_deltaTime);\n        }\n      }\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      if (this.autoClearDepthAndStencil || this.autoClear) {\n        this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n      }\n    }\n  }, {\n    key: \"_checkCameraRenderTarget\",\n    value: function _checkCameraRenderTarget(camera) {\n      var _a;\n      if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {\n        camera.outputRenderTarget._cleared = false;\n      }\n      if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {\n        for (var i = 0; i < camera.rigCameras.length; ++i) {\n          var rtt = camera.rigCameras[i].outputRenderTarget;\n          if (rtt) {\n            rtt._cleared = false;\n          }\n        }\n      }\n    }\n    /**\n     * Resets the draw wrappers cache of all meshes\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n  }, {\n    key: \"resetDrawCache\",\n    value: function resetDrawCache(passId) {\n      if (!this.meshes) {\n        return;\n      }\n      var _iterator17 = _createForOfIteratorHelper(this.meshes),\n        _step22;\n      try {\n        for (_iterator17.s(); !(_step22 = _iterator17.n()).done;) {\n          var mesh = _step22.value;\n          mesh.resetDrawCache(passId);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n    }\n    /**\n     * Render the scene\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var updateCameras = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var ignoreAnimations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _a, _b, _c;\n      if (this.isDisposed) {\n        return;\n      }\n      if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n        this._checkIsReady();\n      }\n      this._frameId++;\n      this._defaultFrameBufferCleared = false;\n      this._checkCameraRenderTarget(this.activeCamera);\n      if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {\n        this.activeCameras.forEach(this._checkCameraRenderTarget);\n      }\n      // Register components that have been associated lately to the scene.\n      this._registerTransientComponents();\n      this._activeParticles.fetchNewFrame();\n      this._totalVertices.fetchNewFrame();\n      this._activeIndices.fetchNewFrame();\n      this._activeBones.fetchNewFrame();\n      this._meshesForIntersections.reset();\n      this.resetCachedMaterial();\n      this.onBeforeAnimationsObservable.notifyObservers(this);\n      // Actions\n      if (this.actionManager) {\n        this.actionManager.processTrigger(11);\n      }\n      // Animations\n      if (!ignoreAnimations) {\n        this.animate();\n      }\n      // Before camera update steps\n      var _iterator18 = _createForOfIteratorHelper(this._beforeCameraUpdateStage),\n        _step23;\n      try {\n        for (_iterator18.s(); !(_step23 = _iterator18.n()).done;) {\n          var step = _step23.value;\n          step.action();\n        }\n        // Update Cameras\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      if (updateCameras) {\n        if (this.activeCameras && this.activeCameras.length > 0) {\n          for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n            var camera = this.activeCameras[cameraIndex];\n            camera.update();\n            if (camera.cameraRigMode !== 0) {\n              // rig cameras\n              for (var index = 0; index < camera._rigCameras.length; index++) {\n                camera._rigCameras[index].update();\n              }\n            }\n          }\n        } else if (this.activeCamera) {\n          this.activeCamera.update();\n          if (this.activeCamera.cameraRigMode !== 0) {\n            // rig cameras\n            for (var _index5 = 0; _index5 < this.activeCamera._rigCameras.length; _index5++) {\n              this.activeCamera._rigCameras[_index5].update();\n            }\n          }\n        }\n      }\n      // Before render\n      this.onBeforeRenderObservable.notifyObservers(this);\n      var engine = this.getEngine();\n      // Customs render targets\n      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n      var currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;\n      if (this.renderTargetsEnabled) {\n        Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n        this._intermediateRendering = true;\n        for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n          var renderTarget = this.customRenderTargets[customIndex];\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n            if (!this.activeCamera) {\n              throw new Error(\"Active camera not set\");\n            }\n            // Viewport\n            engine.setViewport(this.activeCamera.viewport);\n            // Camera\n            this.updateTransformMatrix();\n            renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n          }\n        }\n        Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n        this._intermediateRendering = false;\n        this._renderId++;\n      }\n      this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n      // Restore back buffer\n      this.activeCamera = currentActiveCamera;\n      if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n        this._bindFrameBuffer(this._activeCamera, false);\n      }\n      this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n      var _iterator19 = _createForOfIteratorHelper(this._beforeClearStage),\n        _step24;\n      try {\n        for (_iterator19.s(); !(_step24 = _iterator19.n()).done;) {\n          var _step27 = _step24.value;\n          _step27.action();\n        }\n        // Clear\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n      this._clearFrameBuffer(this.activeCamera);\n      // Collects render targets from external components.\n      var _iterator20 = _createForOfIteratorHelper(this._gatherRenderTargetsStage),\n        _step25;\n      try {\n        for (_iterator20.s(); !(_step25 = _iterator20.n()).done;) {\n          var _step28 = _step25.value;\n          _step28.action(this._renderTargets);\n        }\n        // Multi-cameras?\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (var _cameraIndex = 0; _cameraIndex < this.activeCameras.length; _cameraIndex++) {\n          this._processSubCameras(this.activeCameras[_cameraIndex], _cameraIndex > 0);\n        }\n      } else {\n        if (!this.activeCamera) {\n          throw new Error(\"No camera defined\");\n        }\n        this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n      }\n      // Intersection checks\n      this._checkIntersections();\n      // Executes the after render stage actions.\n      var _iterator21 = _createForOfIteratorHelper(this._afterRenderStage),\n        _step26;\n      try {\n        for (_iterator21.s(); !(_step26 = _iterator21.n()).done;) {\n          var _step29 = _step26.value;\n          _step29.action();\n        }\n        // After render\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      if (this.afterRender) {\n        this.afterRender();\n      }\n      this.onAfterRenderObservable.notifyObservers(this);\n      // Cleaning\n      if (this._toBeDisposed.length) {\n        for (var _index6 = 0; _index6 < this._toBeDisposed.length; _index6++) {\n          var data = this._toBeDisposed[_index6];\n          if (data) {\n            data.dispose();\n          }\n        }\n        this._toBeDisposed.length = 0;\n      }\n      if (this.dumpNextRenderTargets) {\n        this.dumpNextRenderTargets = false;\n      }\n      this._activeBones.addCount(0, true);\n      this._activeIndices.addCount(0, true);\n      this._activeParticles.addCount(0, true);\n      this._engine.restoreDefaultFramebuffer();\n    }\n    /**\n     * Freeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     * Note: multimaterials will not be frozen, but their submaterials will\n     */\n  }, {\n    key: \"freezeMaterials\",\n    value: function freezeMaterials() {\n      for (var i = 0; i < this.materials.length; i++) {\n        this.materials[i].freeze();\n      }\n    }\n    /**\n     * Unfreeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n  }, {\n    key: \"unfreezeMaterials\",\n    value: function unfreezeMaterials() {\n      for (var i = 0; i < this.materials.length; i++) {\n        this.materials[i].unfreeze();\n      }\n    }\n    /**\n     * Releases all held resources\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.isDisposed) {\n        return;\n      }\n      this.beforeRender = null;\n      this.afterRender = null;\n      this.metadata = null;\n      this.skeletons.length = 0;\n      this.morphTargetManagers.length = 0;\n      this._transientComponents.length = 0;\n      this._isReadyForMeshStage.clear();\n      this._beforeEvaluateActiveMeshStage.clear();\n      this._evaluateSubMeshStage.clear();\n      this._preActiveMeshStage.clear();\n      this._cameraDrawRenderTargetStage.clear();\n      this._beforeCameraDrawStage.clear();\n      this._beforeRenderTargetDrawStage.clear();\n      this._beforeRenderingGroupDrawStage.clear();\n      this._beforeRenderingMeshStage.clear();\n      this._afterRenderingMeshStage.clear();\n      this._afterRenderingGroupDrawStage.clear();\n      this._afterCameraDrawStage.clear();\n      this._afterRenderTargetDrawStage.clear();\n      this._afterRenderStage.clear();\n      this._beforeCameraUpdateStage.clear();\n      this._beforeClearStage.clear();\n      this._gatherRenderTargetsStage.clear();\n      this._gatherActiveCameraRenderTargetsStage.clear();\n      this._pointerMoveStage.clear();\n      this._pointerDownStage.clear();\n      this._pointerUpStage.clear();\n      this.importedMeshesFiles = new Array();\n      if (this.stopAllAnimations) {\n        this.stopAllAnimations();\n      }\n      this.resetCachedMaterial();\n      // Smart arrays\n      if (this.activeCamera) {\n        this.activeCamera._activeMeshes.dispose();\n        this.activeCamera = null;\n      }\n      this.activeCameras = null;\n      this._activeMeshes.dispose();\n      this._renderingManager.dispose();\n      this._processedMaterials.dispose();\n      this._activeParticleSystems.dispose();\n      this._activeSkeletons.dispose();\n      this._softwareSkinnedMeshes.dispose();\n      this._renderTargets.dispose();\n      this._materialsRenderTargets.dispose();\n      this._registeredForLateAnimationBindings.dispose();\n      this._meshesForIntersections.dispose();\n      this._toBeDisposed.length = 0;\n      // Abort active requests\n      var activeRequests = this._activeRequests.slice();\n      var _iterator22 = _createForOfIteratorHelper(activeRequests),\n        _step30;\n      try {\n        for (_iterator22.s(); !(_step30 = _iterator22.n()).done;) {\n          var request = _step30.value;\n          request.abort();\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      this._activeRequests.length = 0;\n      // Events\n      try {\n        this.onDisposeObservable.notifyObservers(this);\n      } catch (e) {\n        console.error(\"An error occurred while calling onDisposeObservable!\", e);\n      }\n      this.detachControl();\n      // Detach cameras\n      var canvas = this._engine.getInputElement();\n      if (canvas) {\n        for (var _index7 = 0; _index7 < this.cameras.length; _index7++) {\n          this.cameras[_index7].detachControl();\n        }\n      }\n      // Release animation groups\n      this._disposeList(this.animationGroups);\n      // Release lights\n      this._disposeList(this.lights);\n      // Release meshes\n      this._disposeList(this.meshes, function (item) {\n        return item.dispose(true);\n      });\n      this._disposeList(this.transformNodes, function (item) {\n        return item.dispose(true);\n      });\n      // Release cameras\n      var cameras = this.cameras;\n      this._disposeList(cameras);\n      // Release materials\n      if (this._defaultMaterial) {\n        this._defaultMaterial.dispose();\n      }\n      this._disposeList(this.multiMaterials);\n      this._disposeList(this.materials);\n      // Release particles\n      this._disposeList(this.particleSystems);\n      // Release postProcesses\n      this._disposeList(this.postProcesses);\n      // Release textures\n      this._disposeList(this.textures);\n      // Release morph targets\n      this._disposeList(this.morphTargetManagers);\n      // Release UBO\n      this._sceneUbo.dispose();\n      if (this._multiviewSceneUbo) {\n        this._multiviewSceneUbo.dispose();\n      }\n      // Post-processes\n      this.postProcessManager.dispose();\n      // Components\n      this._disposeList(this._components);\n      // Remove from engine\n      var index = this._engine.scenes.indexOf(this);\n      if (index > -1) {\n        this._engine.scenes.splice(index, 1);\n      }\n      if (EngineStore._LastCreatedScene === this) {\n        if (this._engine.scenes.length > 0) {\n          EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n        } else {\n          EngineStore._LastCreatedScene = null;\n        }\n      }\n      index = this._engine._virtualScenes.indexOf(this);\n      if (index > -1) {\n        this._engine._virtualScenes.splice(index, 1);\n      }\n      this._engine.wipeCaches(true);\n      this.onDisposeObservable.clear();\n      this.onBeforeRenderObservable.clear();\n      this.onAfterRenderObservable.clear();\n      this.onBeforeRenderTargetsRenderObservable.clear();\n      this.onAfterRenderTargetsRenderObservable.clear();\n      this.onAfterStepObservable.clear();\n      this.onBeforeStepObservable.clear();\n      this.onBeforeActiveMeshesEvaluationObservable.clear();\n      this.onAfterActiveMeshesEvaluationObservable.clear();\n      this.onBeforeParticlesRenderingObservable.clear();\n      this.onAfterParticlesRenderingObservable.clear();\n      this.onBeforeDrawPhaseObservable.clear();\n      this.onAfterDrawPhaseObservable.clear();\n      this.onBeforeAnimationsObservable.clear();\n      this.onAfterAnimationsObservable.clear();\n      this.onDataLoadedObservable.clear();\n      this.onBeforeRenderingGroupObservable.clear();\n      this.onAfterRenderingGroupObservable.clear();\n      this.onMeshImportedObservable.clear();\n      this.onBeforeCameraRenderObservable.clear();\n      this.onAfterCameraRenderObservable.clear();\n      this.onAfterRenderCameraObservable.clear();\n      this.onReadyObservable.clear();\n      this.onNewCameraAddedObservable.clear();\n      this.onCameraRemovedObservable.clear();\n      this.onNewLightAddedObservable.clear();\n      this.onLightRemovedObservable.clear();\n      this.onNewGeometryAddedObservable.clear();\n      this.onGeometryRemovedObservable.clear();\n      this.onNewTransformNodeAddedObservable.clear();\n      this.onTransformNodeRemovedObservable.clear();\n      this.onNewMeshAddedObservable.clear();\n      this.onMeshRemovedObservable.clear();\n      this.onNewSkeletonAddedObservable.clear();\n      this.onSkeletonRemovedObservable.clear();\n      this.onNewMaterialAddedObservable.clear();\n      this.onNewMultiMaterialAddedObservable.clear();\n      this.onMaterialRemovedObservable.clear();\n      this.onMultiMaterialRemovedObservable.clear();\n      this.onNewTextureAddedObservable.clear();\n      this.onTextureRemovedObservable.clear();\n      this.onPrePointerObservable.clear();\n      this.onPointerObservable.clear();\n      this.onPreKeyboardObservable.clear();\n      this.onKeyboardObservable.clear();\n      this.onActiveCameraChanged.clear();\n      this.onScenePerformancePriorityChangedObservable.clear();\n      this._isDisposed = true;\n    }\n  }, {\n    key: \"_disposeList\",\n    value: function _disposeList(items, callback) {\n      var itemsCopy = items.slice(0);\n      callback = callback !== null && callback !== void 0 ? callback : function (item) {\n        return item.dispose();\n      };\n      var _iterator23 = _createForOfIteratorHelper(itemsCopy),\n        _step31;\n      try {\n        for (_iterator23.s(); !(_step31 = _iterator23.n()).done;) {\n          var item = _step31.value;\n          callback(item);\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n      items.length = 0;\n    }\n    /**\n     * Gets if the scene is already disposed\n     */\n  }, {\n    key: \"isDisposed\",\n    get: function get() {\n      return this._isDisposed;\n    }\n    /**\n     * Call this function to reduce memory footprint of the scene.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n  }, {\n    key: \"clearCachedVertexData\",\n    value: function clearCachedVertexData() {\n      for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n        var mesh = this.meshes[meshIndex];\n        var geometry = mesh.geometry;\n        if (geometry) {\n          geometry.clearCachedData();\n        }\n      }\n    }\n    /**\n     * This function will remove the local cached buffer data from texture.\n     * It will save memory but will prevent the texture from being rebuilt\n     */\n  }, {\n    key: \"cleanCachedTextureBuffer\",\n    value: function cleanCachedTextureBuffer() {\n      var _iterator24 = _createForOfIteratorHelper(this.textures),\n        _step32;\n      try {\n        for (_iterator24.s(); !(_step32 = _iterator24.n()).done;) {\n          var baseTexture = _step32.value;\n          var buffer = baseTexture._buffer;\n          if (buffer) {\n            baseTexture._buffer = null;\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n    /**\n     * Get the world extend vectors with an optional filter\n     *\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n     */\n  }, {\n    key: \"getWorldExtends\",\n    value: function getWorldExtends(filterPredicate) {\n      var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n      filterPredicate = filterPredicate || function () {\n        return true;\n      };\n      this.meshes.filter(filterPredicate).forEach(function (mesh) {\n        mesh.computeWorldMatrix(true);\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n          return;\n        }\n        var boundingInfo = mesh.getBoundingInfo();\n        var minBox = boundingInfo.boundingBox.minimumWorld;\n        var maxBox = boundingInfo.boundingBox.maximumWorld;\n        Vector3.CheckExtends(minBox, min, max);\n        Vector3.CheckExtends(maxBox, min, max);\n      });\n      return {\n        min: min,\n        max: max\n      };\n    }\n    // Picking\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @returns a Ray\n     */\n  }, {\n    key: \"createPickingRay\",\n    value: function createPickingRay(x, y, world, camera) {\n      var cameraViewSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns the current scene\n     */\n  }, {\n    key: \"createPickingRayToRef\",\n    value: function createPickingRayToRef(x, y, world, result, camera) {\n      var cameraViewSpace = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var enableDistantPicking = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param camera defines the camera to use for the picking\n     * @returns a Ray\n     */\n  }, {\n    key: \"createPickingRayInCameraSpace\",\n    value: function createPickingRayInCameraSpace(x, y, camera) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @returns the current scene\n     */\n  }, {\n    key: \"createPickingRayInCameraSpaceToRef\",\n    value: function createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n      throw _WarnImport(\"Ray\");\n    }\n    /** @internal */\n  }, {\n    key: \"_pickingAvailable\",\n    get: function get() {\n      return false;\n    }\n    /** Launch a ray to try to pick a mesh in the scene\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n  }, {\n    key: \"pick\",\n    value: function pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n      // Dummy info if picking as not been imported\n      return new PickingInfo();\n    }\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n     */\n  }, {\n    key: \"pickWithBoundingInfo\",\n    value: function pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n      // Dummy info if picking as not been imported\n      return new PickingInfo();\n    }\n    /** Use the given ray to pick a mesh in the scene\n     * @param ray The ray to use to pick meshes\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n  }, {\n    key: \"pickWithRay\",\n    value: function pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param x X position on screen\n     * @param y Y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n  }, {\n    key: \"multiPick\",\n    value: function multiPick(x, y, predicate, camera, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param ray Ray to use\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n  }, {\n    key: \"multiPickWithRay\",\n    value: function multiPickWithRay(ray, predicate, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Force the value of meshUnderPointer\n     * @param mesh defines the mesh to use\n     * @param pointerId optional pointer id when using more than one pointer\n     * @param pickResult optional pickingInfo data used to find mesh\n     */\n  }, {\n    key: \"setPointerOverMesh\",\n    value: function setPointerOverMesh(mesh, pointerId, pickResult) {\n      this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n    }\n    /**\n     * Gets the mesh under the pointer\n     * @returns a Mesh or null if no mesh is under the pointer\n     */\n  }, {\n    key: \"getPointerOverMesh\",\n    value: function getPointerOverMesh() {\n      return this._inputManager.getPointerOverMesh();\n    }\n    // Misc.\n    /** @internal */\n  }, {\n    key: \"_rebuildGeometries\",\n    value: function _rebuildGeometries() {\n      var _iterator25 = _createForOfIteratorHelper(this.geometries),\n        _step33;\n      try {\n        for (_iterator25.s(); !(_step33 = _iterator25.n()).done;) {\n          var geometry = _step33.value;\n          geometry._rebuild();\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n      var _iterator26 = _createForOfIteratorHelper(this.meshes),\n        _step34;\n      try {\n        for (_iterator26.s(); !(_step34 = _iterator26.n()).done;) {\n          var mesh = _step34.value;\n          mesh._rebuild();\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n      if (this.postProcessManager) {\n        this.postProcessManager._rebuild();\n      }\n      var _iterator27 = _createForOfIteratorHelper(this._components),\n        _step35;\n      try {\n        for (_iterator27.s(); !(_step35 = _iterator27.n()).done;) {\n          var component = _step35.value;\n          component.rebuild();\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      var _iterator28 = _createForOfIteratorHelper(this.particleSystems),\n        _step36;\n      try {\n        for (_iterator28.s(); !(_step36 = _iterator28.n()).done;) {\n          var system = _step36.value;\n          system.rebuild();\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n      if (this.spriteManagers) {\n        var _iterator29 = _createForOfIteratorHelper(this.spriteManagers),\n          _step37;\n        try {\n          for (_iterator29.s(); !(_step37 = _iterator29.n()).done;) {\n            var spriteMgr = _step37.value;\n            spriteMgr.rebuild();\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_rebuildTextures\",\n    value: function _rebuildTextures() {\n      var _iterator30 = _createForOfIteratorHelper(this.textures),\n        _step38;\n      try {\n        for (_iterator30.s(); !(_step38 = _iterator30.n()).done;) {\n          var texture = _step38.value;\n          texture._rebuild();\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n      this.markAllMaterialsAsDirty(1);\n    }\n    // Tags\n  }, {\n    key: \"_getByTags\",\n    value: function _getByTags(list, tagsQuery, forEach) {\n      if (tagsQuery === undefined) {\n        // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n        return list;\n      }\n      var listByTags = [];\n      forEach = forEach || function (item) {\n        return;\n      };\n      for (var i in list) {\n        var item = list[i];\n        if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n          listByTags.push(item);\n          forEach(item);\n        }\n      }\n      return listByTags;\n    }\n    /**\n     * Get a list of meshes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Mesh\n     */\n  }, {\n    key: \"getMeshesByTags\",\n    value: function getMeshesByTags(tagsQuery, forEach) {\n      return this._getByTags(this.meshes, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of cameras by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Camera\n     */\n  }, {\n    key: \"getCamerasByTags\",\n    value: function getCamerasByTags(tagsQuery, forEach) {\n      return this._getByTags(this.cameras, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of lights by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Light\n     */\n  }, {\n    key: \"getLightsByTags\",\n    value: function getLightsByTags(tagsQuery, forEach) {\n      return this._getByTags(this.lights, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of materials by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Material\n     */\n  }, {\n    key: \"getMaterialByTags\",\n    value: function getMaterialByTags(tagsQuery, forEach) {\n      return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n    }\n    /**\n     * Get a list of transform nodes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of TransformNode\n     */\n  }, {\n    key: \"getTransformNodesByTags\",\n    value: function getTransformNodesByTags(tagsQuery, forEach) {\n      return this._getByTags(this.transformNodes, tagsQuery, forEach);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversly depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n  }, {\n    key: \"setRenderingOrder\",\n    value: function setRenderingOrder(renderingGroupId) {\n      var opaqueSortCompareFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var alphaTestSortCompareFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var transparentSortCompareFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n  }, {\n    key: \"setRenderingAutoClearDepthStencil\",\n    value: function setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var stencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n  }, {\n    key: \"getAutoClearDepthStencilSetup\",\n    value: function getAutoClearDepthStencilSetup(index) {\n      return this._renderingManager.getAutoClearDepthStencilSetup(index);\n    }\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n  }, {\n    key: \"blockMaterialDirtyMechanism\",\n    get: function get() {\n      return this._blockMaterialDirtyMechanism;\n    },\n    set: function set(value) {\n      if (this._blockMaterialDirtyMechanism === value) {\n        return;\n      }\n      this._blockMaterialDirtyMechanism = value;\n      if (!value) {\n        // Do a complete update\n        this.markAllMaterialsAsDirty(63);\n      }\n    }\n    /**\n     * Will flag all materials as dirty to trigger new shader compilation\n     * @param flag defines the flag used to specify which material part must be marked as dirty\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n     */\n  }, {\n    key: \"markAllMaterialsAsDirty\",\n    value: function markAllMaterialsAsDirty(flag, predicate) {\n      if (this._blockMaterialDirtyMechanism) {\n        return;\n      }\n      var _iterator31 = _createForOfIteratorHelper(this.materials),\n        _step39;\n      try {\n        for (_iterator31.s(); !(_step39 = _iterator31.n()).done;) {\n          var material = _step39.value;\n          if (predicate && !predicate(material)) {\n            continue;\n          }\n          material.markAsDirty(flag);\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_loadFile\",\n    value: function _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n      var _this10 = this;\n      var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n      this._activeRequests.push(request);\n      request.onCompleteObservable.add(function (request) {\n        _this10._activeRequests.splice(_this10._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_loadFileAsync\",\n    value: function _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n      var _this11 = this;\n      return new Promise(function (resolve, reject) {\n        _this11._loadFile(fileOrUrl, function (data) {\n          resolve(data);\n        }, onProgress, useOfflineSupport, useArrayBuffer, function (request, exception) {\n          reject(exception);\n        }, onOpened);\n      });\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_requestFile\",\n    value: function _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n      var _this12 = this;\n      var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n      this._activeRequests.push(request);\n      request.onCompleteObservable.add(function (request) {\n        _this12._activeRequests.splice(_this12._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_requestFileAsync\",\n    value: function _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n      var _this13 = this;\n      return new Promise(function (resolve, reject) {\n        _this13._requestFile(url, function (data) {\n          resolve(data);\n        }, onProgress, useOfflineSupport, useArrayBuffer, function (error) {\n          reject(error);\n        }, onOpened);\n      });\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_readFile\",\n    value: function _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n      var _this14 = this;\n      var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n      this._activeRequests.push(request);\n      request.onCompleteObservable.add(function (request) {\n        _this14._activeRequests.splice(_this14._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_readFileAsync\",\n    value: function _readFileAsync(file, onProgress, useArrayBuffer) {\n      var _this15 = this;\n      return new Promise(function (resolve, reject) {\n        _this15._readFile(file, function (data) {\n          resolve(data);\n        }, onProgress, useArrayBuffer, function (error) {\n          reject(error);\n        });\n      });\n    }\n    /**\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n     * @returns the perf collector belonging to the scene.\n     */\n  }, {\n    key: \"getPerfCollector\",\n    value: function getPerfCollector() {\n      throw _WarnImport(\"performanceViewerSceneExtension\");\n    }\n  }], [{\n    key: \"DefaultMaterialFactory\",\n    value:\n    /**\n     * Factory used to create the default material.\n     * @param scene The scene to create the material for\n     * @returns The default material\n     */\n    function DefaultMaterialFactory(scene) {\n      throw _WarnImport(\"StandardMaterial\");\n    }\n    /**\n     * Factory used to create the a collision coordinator.\n     * @returns The collision coordinator\n     */\n  }, {\n    key: \"CollisionCoordinatorFactory\",\n    value: function CollisionCoordinatorFactory() {\n      throw _WarnImport(\"DefaultCollisionCoordinator\");\n    }\n  }, {\n    key: \"DragMovementThreshold\",\n    get: function get() {\n      return InputManager.DragMovementThreshold;\n    },\n    set: function set(value) {\n      InputManager.DragMovementThreshold = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n  }, {\n    key: \"LongPressDelay\",\n    get: function get() {\n      return InputManager.LongPressDelay;\n    },\n    set: function set(value) {\n      InputManager.LongPressDelay = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n  }, {\n    key: \"DoubleClickDelay\",\n    get: function get() {\n      return InputManager.DoubleClickDelay;\n    },\n    set: function set(value) {\n      InputManager.DoubleClickDelay = value;\n    }\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n  }, {\n    key: \"ExclusiveDoubleClickMode\",\n    get: function get() {\n      return InputManager.ExclusiveDoubleClickMode;\n    },\n    set: function set(value) {\n      InputManager.ExclusiveDoubleClickMode = value;\n    }\n  }]);\n  return Scene;\n}(AbstractScene);\n/** The fog is deactivated */\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MaxDeltaTime = 1000.0;\n/**\n * @internal\n */\nScene.prototype.setActiveCameraByID = function (id) {\n  return this.setActiveCameraById(id);\n};\nScene.prototype.getLastMaterialByID = function (id) {\n  return this.getLastMaterialById(id);\n};\nScene.prototype.getMaterialByID = function (id) {\n  return this.getMaterialById(id);\n};\nScene.prototype.getTextureByUniqueID = function (uniqueId) {\n  return this.getTextureByUniqueId(uniqueId);\n};\nScene.prototype.getCameraByID = function (id) {\n  return this.getCameraById(id);\n};\nScene.prototype.getCameraByUniqueID = function (uniqueId) {\n  return this.getCameraByUniqueId(uniqueId);\n};\nScene.prototype.getBoneByID = function (id) {\n  return this.getBoneById(id);\n};\nScene.prototype.getLightByID = function (id) {\n  return this.getLightById(id);\n};\nScene.prototype.getLightByUniqueID = function (uniqueId) {\n  return this.getLightByUniqueId(uniqueId);\n};\nScene.prototype.getParticleSystemByID = function (id) {\n  return this.getParticleSystemById(id);\n};\nScene.prototype.getGeometryByID = function (id) {\n  return this.getGeometryById(id);\n};\nScene.prototype.getMeshByID = function (id) {\n  return this.getMeshById(id);\n};\nScene.prototype.getMeshesByID = function (id) {\n  return this.getMeshesById(id);\n};\nScene.prototype.getTransformNodeByID = function (id) {\n  return this.getTransformNodeById(id);\n};\nScene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n  return this.getTransformNodeByUniqueId(uniqueId);\n};\nScene.prototype.getTransformNodesByID = function (id) {\n  return this.getTransformNodesById(id);\n};\nScene.prototype.getMeshByUniqueID = function (uniqueId) {\n  return this.getMeshByUniqueId(uniqueId);\n};\nScene.prototype.getLastMeshByID = function (id) {\n  return this.getLastMeshById(id);\n};\nScene.prototype.getLastEntryByID = function (id) {\n  return this.getLastEntryById(id);\n};\nScene.prototype.getNodeByID = function (id) {\n  return this.getNodeById(id);\n};\nScene.prototype.getLastSkeletonByID = function (id) {\n  return this.getLastSkeletonById(id);\n};"],"names":["ScenePerformancePriority","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_isNativeReflectConstruct","result","Super","NewTarget","this","arguments","Scene","_AbstractScene","_super","engine","options","_this","_inputManager","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClear","autoClearDepthAndStencil","clearColor","ambientColor","environmentIntensity","_performancePriority","BackwardCompatible","onScenePerformancePriorityChangedObservable","_forceWireframe","_skipFrustumClipping","_forcePointsCloud","animationsEnabled","_animationPropertiesOverride","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","onDisposeObservable","_onDisposeObserver","onBeforeRenderObservable","_onBeforeRenderObserver","onAfterRenderObservable","onAfterRenderCameraObservable","_onAfterRenderObserver","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeCameraRenderObservable","_onBeforeCameraRenderObserver","onAfterCameraRenderObservable","_onAfterCameraRenderObserver","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onActiveCameraChanged","onActiveCamerasChanged","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","_registeredForLateAnimationBindings","skipPointerMovePicking","skipPointerDownPicking","skipPointerUpPicking","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_useRightHandedSystem","_timeAccumulator","_currentStepId","_currentInternalStep","_fogEnabled","_fogMode","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","_shadowsEnabled","_lightsEnabled","_unObserveActiveCameras","_texturesEnabled","physicsEnabled","particlesEnabled","spritesEnabled","_skeletonsEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","requireLightSorting","_components","_serializableComponents","_transientComponents","_beforeCameraUpdateStage","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterCameraPostProcessStage","_afterRenderTargetDrawStage","_afterRenderTargetPostProcessStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_registeredActions","_blockMaterialDirtyMechanism","_perfCollector","activeCameras","fullOptions","target","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_objectSpread","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","_virtualScenes","scenes","_uid","_renderingManager","postProcessManager","attachControl","_createUbo","_imageProcessingConfiguration","setDefaultCandidateProviders","onNewSceneAddedObservable","notifyObservers","get","_environmentTexture","set","markAllMaterialsAsDirty","skipFrustumClipping","maintainStateBetweenFrames","Intermediate","Aggressive","callback","remove","add","unTranslatedPointer","effect","_a","variableName","undefined","isVector3","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","devicePosition","invertNormal","useRightHandedSystem","x","y","z","setFloat3","setVector4","ubo","getSceneUniformBuffer","bindEyePosition","updateFloat4","w","update","newStepId","prePassRenderer","defaultRT","enabled","_activeCameras","cameras","_this2","_activeCamera","_defaultMaterial","DefaultMaterialFactory","_collisionCoordinator","CollisionCoordinatorFactory","init","_frustumPlanes","_step","_iterator","register","component","serializableComponent","addFromContainer","serialize","_step2","_iterator2","meshes","mesh","subMeshes","getActiveMeshCandidates","_getDefaultMeshCandidates","bind","getActiveSubMeshCandidates","_getDefaultSubMeshCandidates","getIntersectingSubMeshCandidates","getCollidingSubMeshCandidates","meshUnderPointer","pointerX","pointerY","_cachedMaterial","_cachedEffect","_cachedVisibility","material","visibility","current","_animationRatio","setSceneUniformBuffer","createSceneUniformBuffer","pickResult","pointerEventInit","simulatePointerMove","simulatePointerDown","doubleTap","simulatePointerUp","pointerId","isPointerCaptured","attachUp","attachDown","attachMove","detachControl","index","checkRenderTargets","getEngine","isReady","reset","_step3","hardwareInstancedRendering","hasThinInstances","getClassName","getCaps","instancedArrays","instances","_iterator3","action","mat","defaultMaterial","_storeEffectOnSubMeshes","_step4","_iterator4","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","areAllEffectsReady","isReadyForRendering","geometries","delayLoadState","_step5","_iterator5","_step6","_iterator6","particleSystems","func","removeCallback","_this3","registerBeforeRender","execFunc","setTimeout","unregisterBeforeRender","timeout","_this4","_executeOnceBeforeRender","wasLoading","isLoading","splice","addOnce","_checkIsReady","_this5","Promise","resolve","executeWhenReady","_this6","_registerTransientComponents","clear","incrementRenderId","_animationTimeLast","_viewMatrix","_projectionMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","UniqueId","newMesh","_this7","recursive","_resyncLightSources","parent","_addToSceneRootNodes","getChildMeshes","m","addMesh","toRemove","_this8","pop","_removeFromSceneRootNodes","_invalidateMesh","removeMesh","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","lastNode","skeletons","_executeActiveContainerCleanup","morphTargetManagers","lights","_step7","_iterator7","_removeLightSource","sortLightsByPriority","index2","animations","animationName","targetMask","animationGroups","multiMaterials","_indexInSceneMaterialArray","materials","lastMaterial","actionManagers","textures","newLight","_step8","_iterator8","lightSources","sort","newCamera","newSkeleton","newParticleSystem","newAnimation","newAnimationGroup","newMultiMaterial","newMaterial","newMorphTargetManager","newGeometry","uniqueId","newActionManager","newTexture","getInputElement","id","camera","getCameraById","getCameraByName","allowMultiMaterials","predicate","_index","_material","_getMaterial","_index2","skeletonIndex","skeleton","boneIndex","bones","_index3","geometry","force","_getGeometryByUniqueId","addGeometry","lastGeometry","getMeshById","transformNode","getTransformNodeById","light","getLightById","bone","getBoneById","getMeshByName","getTransformNodeByName","getLightByName","getBoneByName","managerIndex","morphTargetManager","numTargets","getTarget","postProcessIndex","postProcesses","postProcess","_externalData","factory","getOrAddWithFactory","subMesh","initialMesh","forcePush","isInFrustum","_step9","_iterator9","dispatch","freeActiveMeshes","freeRenderingGroups","blockfreeActiveMeshesAndRenderingGroups","texture","renderList","_this9","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","_internalAbstractMeshDataInfo","_isActive","_index4","_unFreeze","container","snapshotRendering","snapshotRenderingMode","_len","computeWorldMatrix","psLength","_i","animate","resetSprites","_step10","_iterator10","_i2","_mesh","_currentLODIsUpToDate","isBlocked","addCount","getTotalVertices","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","alwaysSelectAsActiveMesh","_activate","_step11","_iterator11","isAnInstance","_actAsRegularMesh","_onlyForInstances","_activeMesh","_postActivate","particleIndex","particleSystem","isStarted","emitter","position","dispatchParticles","sourceMesh","prepare","computeBonesUsingShaders","hasInstances","_evaluateSubMesh","_renderingMultiview","leftCamera","_rigCameras","rightCamera","setTransformMatrix","getViewMatrix","getProjectionMatrix","_multiviewTexture","_bindFrameBuffer","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","rtt","onClearObservable","hasObservers","skipInitialClear","_cleared","_clear","rigParent","_b","_c","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","resetCachedMaterial","prePass","softwareSkinnedMeshIndex","applySkeleton","environmentTexture","isRenderTarget","_step13","_iterator12","needRebind","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","_step14","_iterator13","currentRenderPassId","renderPassId","_prepareFrame","_step15","_iterator14","finalizeSceneUbo","_step16","_iterator15","_finalizeFrame","isIntermediate","_step17","_iterator16","cameraRigMode","_createMultiviewUbo","_renderForCamera","_useMultiviewToSingleView","_renderMultiviewToSingleView","_loop","actions","actionIndex","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","hasSpecificTrigger","parameter","parameterMesh","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_animate","_advancePhysicsEngineStep","_deltaTime","forceWireframe","forcePointsCloud","isRigCamera","rigCameras","passId","_step22","_iterator17","resetDrawCache","updateCameras","ignoreAnimations","isDisposed","_checkCameraRenderTarget","fetchNewFrame","processTrigger","_step23","_iterator18","cameraIndex","_index5","currentActiveCamera","customIndex","_step24","_iterator19","_step25","_iterator20","_cameraIndex","_processSubCameras","_checkIntersections","_step26","_iterator21","afterRender","_index6","freeze","unfreeze","beforeRender","stopAllAnimations","_step30","_iterator22","abort","console","error","_index7","_disposeList","item","wipeCaches","items","_step31","_iterator23","meshIndex","clearCachedData","_step32","_iterator24","baseTexture","_buffer","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","world","fastCheck","trianglePredicate","ray","setPointerOverMesh","getPointerOverMesh","_step33","_iterator25","_rebuild","_step34","_iterator26","_step35","_iterator27","rebuild","_step36","_iterator28","spriteManagers","_step37","_iterator29","_step38","_iterator30","list","tagsQuery","listByTags","_getByTags","concat","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingOrder","autoClearDepthStencil","depth","stencil","setRenderingAutoClearDepthStencil","getAutoClearDepthStencilSetup","flag","_step39","_iterator31","markAsDirty","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","_this10","request","offlineProvider","onCompleteObservable","_this11","reject","_loadFile","exception","url","_this12","_this13","_requestFile","file","_this14","_this15","_readFile","scene","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR","setActiveCameraByID","setActiveCameraById","getLastMaterialByID","getLastMaterialById","getMaterialByID","getMaterialById","getTextureByUniqueID","getTextureByUniqueId","getCameraByID","getCameraByUniqueID","getCameraByUniqueId","getBoneByID","getLightByID","getLightByUniqueID","getLightByUniqueId","getParticleSystemByID","getParticleSystemById","getGeometryByID","getGeometryById","getMeshByID","getMeshesByID","getMeshesById","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodeByUniqueId","getTransformNodesByID","getTransformNodesById","getMeshByUniqueID","getMeshByUniqueId","getLastMeshByID","getLastMeshById","getLastEntryByID","getLastEntryById","getNodeByID","getNodeById","getLastSkeletonByID","getLastSkeletonById"],"sourceRoot":""}